<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bisección - Métodos Numéricos</title>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- <link rel="stylesheet" href="../style.css"> --> <!-- Comentado para priorizar Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script> <!-- Tailwind CSS CDN -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'], // Establecer Inter como fuente sans por defecto
                    },
                    colors: {
                        'custom-blue': '#242A38',
                        'custom-red': '#E94560',
                        'custom-gray-bg': '#F3F4F6',
                        'sidebar-bg': '#FFFFFF',
                        'sidebar-text': '#4B5563',
                        'sidebar-hover-bg': '#FEF2F2',
                    }
                }
            }
        }
    </script>
    <!-- Configuración de MathJax -->
    <script>
        window.MathJax = {
            tex: {
                packages: {'[+]': ['input/mml', 'output/chtml']}
            },
            chtml: { 
                matchFontHeight: false
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Pyodide y Chart.js -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        @keyframes animatedRainbowBorder {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        .animate-rainbow-border::before {
            content: ''; position: absolute; z-index: -1; top: -2px; left: -2px; right: -2px; bottom: -2px;
            border-radius: 9999px;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #007bff, #8a2be2, #ff00ff, #ff0000);
            background-size: 200% 100%;
            animation: animatedRainbowBorder 3s linear infinite;
        }
        .animate-rainbow-border { position: relative; z-index: 0; }

        /* Estilos para prevenir estiramiento de la barra lateral */
        body.content-ready .container-with-sidebar,
        body.content-ready aside,
        body.content-ready main,
        body.content-ready .right-sidebar-fixed {
            opacity: 0;
            visibility: visible;
        }
        
        body.loaded .container-with-sidebar,
        body.loaded aside,
        body.loaded main,
        body.loaded .right-sidebar-fixed {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.4s ease-in;
        }
        
        .container-with-sidebar,
        aside,
        main,
        .right-sidebar-fixed {
            opacity: 0;
            visibility: hidden;
        }
        
        @media (min-width: 1024px) {
            .right-sidebar-fixed {
                width: 300px !important;
                flex: 0 0 300px !important;
                min-width: 300px !important;
                max-width: 300px !important;
                box-sizing: border-box !important;
            }
            
            /* Estilos para la barra lateral izquierda - controlando ambos estados */
            /* Cuando está expandida */
            aside[class*="lg:w-64"] {
                width: 300px !important;
                flex: 0 0 300px !important;
                min-width: 300px !important;
                max-width: 300px !important;
                box-sizing: border-box !important;
                transition: all 0.3s ease-in-out !important;
            }
            
            /* Cuando está contraída */
            aside[class*="lg:w-20"] {
                width: 80px !important;
                flex: 0 0 80px !important;
                min-width: 80px !important;
                max-width: 80px !important;
                box-sizing: border-box !important;
                transition: all 0.3s ease-in-out !important;
            }
            
            .main-content-fixed {
                flex: 1 1 auto !important;
            }
            
            .sidebar-preloader {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: #F3F4F6;
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 9999;
            }
            
            .sidebar-preloader.hidden {
                display: none;
            }
            
            .loading-spinner {
                border: 4px solid rgba(0, 0, 0, 0.1);
                border-left-color: #E94560;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
            }
            
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        }

        /* Styles for fullscreen code output - Biseccion */
        .bis-output-fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9990 !important; 
            background-color: #111827 !important; /* bg-gray-900 */
            padding: 20px !important;
            margin: 0 !important;
            border-radius: 0 !important;
            overflow-y: auto !important;
            max-height: 100vh !important;
        }
        .bis-body-fullscreen-active {
            overflow: hidden !important;
        }
        .bis-output-controls-container-fixed {
            position: fixed !important;
            top: 15px !important; /* Consistent with regla-falsa */
            right: 15px !important; /* Consistent with regla-falsa */
            z-index: 9999 !important; 
            display: flex !important; 
            align-items: center !important;
            gap: 0.25rem !important; /* space-x-1 */
        }

        /* Flash animations for font buttons - Biseccion */
        .bis-font-button-flash-red {
            animation: bis-flash-red 0.4s ease-out;
        }
        @keyframes bis-flash-red {
            0% { background-color: #EF4444; } /* red-500 */
            100% { background-color: #374151; } /* gray-700, original button color */
        }
        .bis-font-button-flash-blue {
            animation: bis-flash-blue 0.4s ease-out;
        }
        @keyframes bis-flash-blue {
            0% { background-color: #3B82F6; } /* blue-500 */
            100% { background-color: #374151; } /* gray-700, original button color */
        }
    </style>
</head>
<body class="bg-custom-gray-bg text-gray-700 font-sans antialiased">
    <div id="app">
        <header class="bg-custom-blue text-white shadow-md">
            <div class="container mx-auto px-4 py-3 flex justify-between items-center">
                <h1 class="text-xl font-semibold"><a href="/" class="hover:text-gray-300">Métodos Numéricos</a></h1>
                <nav><a href="../index.html#method-cards-container" class="text-sm px-4 py-2 rounded-md hover:bg-gray-700 transition-colors duration-150">Volver a Métodos</a></nav>
            </div>
        </header>
        
        <!-- Preloader mientras se inicializa la interfaz -->
        <div id="sidebar-preloader" class="sidebar-preloader">
            <div class="loading-spinner"></div>
        </div>

        <div class="container mx-auto mt-8 mb-8 flex flex-col lg:flex-row lg:space-x-8 px-4 container-with-sidebar">
            <left-sidebar></left-sidebar>
            <main class="w-full flex-1 min-w-0 bg-white shadow-xl rounded-lg p-6 md:p-8 order-2 mb-6 lg:mb-0 main-content-fixed">
                <article class="method-content">
                    <h2 class="text-3xl font-bold mb-6 text-gray-800 border-b border-gray-200 pb-4">Método de Bisección</h2>
                    <section id="teoria" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Fundamento Teórico (Según Chapra)</h3>
                        <p class="text-gray-600 leading-relaxed mb-4">
                            El método de bisección, también conocido como de corte binario, de partición de intervalos o de Bolzano, es un tipo de método incremental donde el intervalo se divide siempre por la mitad. Si una función cambia de signo sobre un intervalo, se evalúa el valor de la función en el punto medio. La posición de la raíz se determina entonces situándola en el punto medio del subintervalo, dentro del cual ocurre el cambio de signo.
                        </p>
                        <p class="text-gray-600 leading-relaxed mb-4">
                            Se basa en el hecho de que si una función real y continua \(f(x)\) tiene signos opuestos en los extremos de un intervalo \([x_l, x_u]\) (límite inferior \(x_l\) y límite superior \(x_u\)), es decir, \(f(x_l)f(x_u) < 0\), entonces debe haber al menos una raíz real entre \(x_l\) y \(x_u\). Este es el Teorema del Valor Intermedio.
                        </p>
                        <p class="text-gray-600 leading-relaxed mb-4">
                            En cada iteración, el intervalo se divide a la mitad para obtener una nueva estimación de la raíz, \(x_r = (x_l + x_u) / 2\). Luego se realizan las siguientes evaluaciones para determinar si la raíz está en la mitad inferior o superior del intervalo:
                        </p>
                        <ul class="list-disc list-inside space-y-2 pl-4 text-gray-600 mb-4">
                            <li>Si \(f(x_l)f(x_r) < 0\), la raíz se encuentra en la mitad inferior. Entonces, \(x_u\) se redefine como \(x_r\) y se continúa con la siguiente iteración.</li>
                            <li>Si \(f(x_l)f(x_r) > 0\), la raíz se encuentra en la mitad superior. Entonces, \(x_l\) se redefine como \(x_r\) y se continúa con la siguiente iteración.</li>
                            <li>Si \(f(x_l)f(x_r) = 0\), la raíz es igual a \(x_r\) y el cómputo termina.</li>
                        </ul>
                    </section>
                    <section id="algoritmo" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Pasos del Algoritmo</h3>
                        <ol class="list-decimal list-inside space-y-3 pl-4 text-gray-600 leading-relaxed">
                            <li><strong>Paso 1:</strong> Escoger las aproximaciones iniciales inferior \(x_l\) y superior \(x_u\) que encierren la raíz, de tal forma que la función cambie de signo en el intervalo. Esto se puede verificar comprobando que \(f(x_l)f(x_u) < 0\).</li>
                            <li><strong>Paso 2:</strong> Una aproximación de la raíz \(x_r\) se determina mediante:
                                <p style="text-align:center;" class="mt-2 mb-2">\(x_r = \frac{x_l + x_u}{2}\)</p>
                            </li>
                            <li><strong>Paso 3:</strong> Realizar las siguientes evaluaciones para determinar en qué subintervalo está la raíz:
                                <ul class="list-disc list-inside space-y-1 pl-6 mt-2">
                                    <li>a) Si \(f(x_l)f(x_r) < 0\), la raíz se encuentra dentro del subintervalo inferior o izquierdo. Por lo tanto, haga \(x_u = x_r\) y continúe con el paso 2.</li>
                                    <li>b) Si \(f(x_l)f(x_r) > 0\), la raíz se encuentra dentro del subintervalo superior o derecho. Por lo tanto, haga \(x_l = x_r\) y continúe con el paso 2.</li>
                                    <li>c) Si \(f(x_l)f(x_r) = 0\), la raíz es igual a \(x_r\); termina el cálculo.</li>
                                </ul>
                            </li>
                            <li><strong>Criterio de terminación:</strong> El proceso se repite hasta que la aproximación sea lo suficientemente exacta. Un criterio común es que el error relativo aproximado \(\epsilon_a\) sea menor que un valor preestablecido \(\epsilon_s\):
                                <p style="text-align:center;" class="mt-2 mb-2">\(\epsilon_a = \left| \frac{x_r^{\text{nuevo}} - x_r^{\text{anterior}}}{x_r^{\text{nuevo}}} \right| \times 100\% \le \epsilon_s\)</p>
                                También se puede establecer un número máximo de iteraciones.
                            </li>
                        </ol>
                    </section>
                    <section id="ejemplo" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Ejemplo Paso a Paso (Según Chapra)</h3>
                        <p class="text-gray-600 leading-relaxed mb-3">
                            <strong>Problema:</strong> Usar el método de bisección para encontrar la raíz de \(f(x) = e^{-x} - x\). Use como valores iniciales \(x_l = 0\) y \(x_u = 1\).
                        </p>
                        <p class="text-gray-600 leading-relaxed mb-3">
                            Calculamos \(f(x_l) = f(0) = e^0 - 0 = 1\) y \(f(x_u) = f(1) = e^{-1} - 1 \approx 0.36788 - 1 = -0.63212\).
                        </p>
                        <p class="text-gray-600 leading-relaxed mb-4">
                            Como \(f(0)f(1) < 0\), la raíz está entre 0 y 1.
                        </p>
                    
                        <p class="font-medium text-gray-700 mb-1"><strong>Iteración 1:</strong></p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">\(x_r = (0 + 1) / 2 = 0.5\)</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">\(f(0.5) = e^{-0.5} - 0.5 \approx 0.60653 - 0.5 = 0.10653\)</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">Como \(f(x_l)f(x_r) = f(0)f(0.5) = (1)(0.10653) > 0\), la raíz está en el intervalo superior. Nuevo intervalo: \(x_l = 0.5, x_u = 1\).</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-4">Error relativo aproximado (\(\epsilon_a\)) no se puede calcular en la primera iteración.</p>
                    
                        <p class="font-medium text-gray-700 mb-1"><strong>Iteración 2:</strong></p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">\(x_r = (0.5 + 1) / 2 = 0.75\)</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">\(f(0.75) = e^{-0.75} - 0.75 \approx 0.47237 - 0.75 = -0.27763\)</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">Como \(f(x_l)f(x_r) = f(0.5)f(0.75) = (0.10653)(-0.27763) < 0\), la raíz está en el intervalo inferior. Nuevo intervalo: \(x_l = 0.5, x_u = 0.75\).</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-4">\(\epsilon_a = |(0.75 - 0.5) / 0.75| \times 100\% = 33.33\%\)</p>
                    
                        <p class="font-medium text-gray-700 mb-1"><strong>Iteración 3:</strong></p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">\(x_r = (0.5 + 0.75) / 2 = 0.625\)</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">\(f(0.625) = e^{-0.625} - 0.625 \approx 0.53526 - 0.625 = -0.08974\)</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-1">Como \(f(x_l)f(x_r) = f(0.5)f(0.625) = (0.10653)(-0.08974) < 0\), la raíz está en el intervalo inferior. Nuevo intervalo: \(x_l = 0.5, x_u = 0.625\).</p>
                        <p class="text-gray-600 leading-relaxed ml-4 mb-4">\(\epsilon_a = |(0.625 - 0.75) / 0.625| \times 100\% = 20.00\%\)</p>
                    
                        <p class="text-gray-600 leading-relaxed italic mb-2"><em>(El proceso continuaría hasta que \(\epsilon_a\) sea menor que la tolerancia deseada. Chapra usualmente muestra tablas con más iteraciones.)</em></p>
                        <p class="text-gray-600 leading-relaxed">Por ejemplo, si se deseara una \(\epsilon_s < 0.5\%, las iteraciones continuarían. La raíz verdadera es aproximadamente 0.56714329.</p>
                    </section>
                    <section id="codigo" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Código de Implementación (Python) - Ejecutable</h3>
                        <div class="code-editor-container bg-gray-50 p-4 rounded-lg shadow-inner">
                            <textarea id="biseccion-code-input" class="code-input w-full h-72 p-3 border border-gray-300 rounded-md font-mono text-sm" style="resize: none;">import math

def funcion_ejemplo(x):
    # f(x) = x^3 - x - 2
    return x**3 - x - 2

def bisection_method(func, a, b, tol=1e-6, max_iter=100):
    '''Implementa el método de bisección y retorna salida HTML y datos de iteración.'''
    html_output = ''
    iter_data_list = []

    if func(a) * func(b) >= 0:
        html_output += '<p style="color: red; text-align:center;">Error: La función debe tener signos opuestos en los extremos a y b.</p>'
        return None, iter_data_list, html_output

    iter_count = 0
    # Añadir estado inicial
    iter_data_list.append({'iter': 0, 'a': a, 'b': b, 'c': None, 'fa': func(a), 'fb': func(b), 'fc': None, 'error': None})

    html_output += '<table border="1" style="width:100%; border-collapse: collapse; margin-bottom:15px; font-size: 0.85em;">'
    html_output += '<thead><tr>'
    headers = ["Iter", "a", "b", "c (xr)", "f(c)", "Error (%)"]
    for h in headers:
        html_output += f'<th style="padding: 4px; text-align:center;">{h}</th>'
    html_output += '</tr></thead><tbody>'
    
    c_prev = a # Inicializar c_prev para cálculo de error

    while (b - a) / 2.0 > tol and iter_count < max_iter:
        c = (a + b) / 2.0
        fc = func(c)
        
        error_rel_aprox = abs((c - c_prev) / c) * 100 if c != 0 and iter_count > 0 else float('inf')
        
        html_output += '<tr>'
        html_output += f'<td style="padding: 4px; text-align:center;">{iter_count+1}</td>'
        html_output += f'<td style="padding: 4px; text-align:right; padding-right:5px;">{a:.6f}</td>'
        html_output += f'<td style="padding: 4px; text-align:right; padding-right:5px;">{b:.6f}</td>'
        html_output += f'<td style="padding: 4px; text-align:right; padding-right:5px;">{c:.6f}</td>'
        html_output += f'<td style="padding: 4px; text-align:right; padding-right:5px;">{fc:.6f}</td>'
        if iter_count == 0:
            html_output += '<td style="padding: 4px; text-align:center;">-</td>'
        else:
            html_output += f'<td style="padding: 4px; text-align:right; padding-right:5px;">{error_rel_aprox:.4f}</td>'
        html_output += '</tr>'

        iter_data_list.append({'iter': iter_count+1, 'a': a, 'b': b, 'c': c, 'fa': func(a), 'fb': func(b), 'fc': fc, 'error': error_rel_aprox if iter_count > 0 else None})

        if fc == 0.0: # Encontró la raíz exacta
            html_output += '</tbody></table>'
            html_output += f'<div style="text-align: center; color: green; margin-top:10px;">Raíz exacta encontrada en x = {c} después de {iter_count+1} iteraciones.</div>'
            # global js_iteration_data_bis # Pyodide specific
            # js_data_container_bis = js_iteration_data_bis
            # js_data_container_bis.clear()
            # for item_bis in iter_data_list:
            #     js_data_container_bis.append(item_bis)
            return c, iter_data_list, html_output
        elif func(a) * fc < 0:
            b = c
        else:
            a = c
            
        c_prev = c 
        iter_count += 1

    html_output += '</tbody></table>'
    c_final = (a + b) / 2.0
    if iter_count == max_iter:
        html_output += f'<div style="text-align: center; color: orange; margin-top:10px;">AVISO: Máximo número de iteraciones ({max_iter}) alcanzado.</div>'
    else:
        html_output += f'<div style="text-align: center; color: green; margin-top:10px;">CONVERGENCIA alcanzada después de {iter_count} iteraciones (tolerancia={tol}).</div>'
    
    # global js_iteration_data_bis # Pyodide specific
    # js_data_container_bis = js_iteration_data_bis
    # js_data_container_bis.clear()
    # for item_bis in iter_data_list:
    #     js_data_container_bis.append(item_bis)
            
    return c_final, iter_data_list, html_output

def mostrar_resultados_biseccion(raiz, funcion, nombre_funcion='f(x)'):
    '''Muestra los resultados finales con formato HTML mejorado para Bisección.'''
    html_res = ''
    if raiz is not None:
        html_res += '<div style="text-align: center; font-weight: bold; margin-top: 20px; margin-bottom: 10px;">RESULTADOS FINALES (BISECCIÓN)</div>'
        html_res += '<table border="1" style="width:auto; margin-left:auto; margin-right:auto; border-collapse: collapse; font-size: 0.9em;">'
        html_res += '<tbody>'
        html_res += f'<tr><td style="padding: 5px; text-align:left;">Raíz aproximada:</td><td style="padding: 5px; text-align:right;">{raiz:.8f}</td></tr>'
        html_res += f'<tr><td style="padding: 5px; text-align:left;">Evaluación {nombre_funcion}(raíz):</td><td style="padding: 5px; text-align:right;">{funcion(raiz):.8e}</td></tr>'
        html_res += '</tbody></table>'
    else:
        html_res += '<p style="text-align:center; color:red; margin-top:10px;">No se pudo encontrar una raíz con los parámetros dados.</p>'
    return html_res

# --- Parámetros Ejemplo ---
if __name__ == "__main__":
    output_buffer_bis = []
    
    a_intervalo = 1.0
    b_intervalo = 2.0
    tolerancia_error_biseccion = 1e-4 # Tolerancia para el error relativo porcentual
    max_iter_biseccion = 50

    nombre_func_str = 'f(x) = x³ - x - 2'
    
    initial_info_html_bis = '<div style="text-align: center; font-weight: bold; margin-bottom:15px; font-size:1.1em;">MÉTODO DE BISECCIÓN - SOLUCIÓN DE ECUACIONES NO LINEALES</div>'
    initial_info_html_bis += f'<div style="text-align: center; margin-bottom:5px;">Función: {nombre_func_str}</div>'
    initial_info_html_bis += f'<div style="text-align: center; margin-bottom:5px;">Intervalo inicial: [{a_intervalo}, {b_intervalo}]</div>'
    initial_info_html_bis += f'<div style="text-align: center; margin-bottom:15px;">Tolerancia Error Relativo: {tolerancia_error_biseccion}</div>'
    
    output_buffer_bis.append(initial_info_html_bis)
    
    raiz_aproximada, iteraciones_py_bis, tabla_html_bis = bisection_method(funcion_ejemplo, a_intervalo, b_intervalo, tol=tolerancia_error_biseccion, max_iter=max_iter_biseccion)
    output_buffer_bis.append(tabla_html_bis)
    
    if raiz_aproximada is not None:
        resultados_html_bis = mostrar_resultados_biseccion(raiz_aproximada, funcion_ejemplo, nombre_funcion='f')
        output_buffer_bis.append(resultados_html_bis)

    # Para Pyodide, la variable global 'pyodide_html_output' contendrá el resultado.
    # También se poblará 'js_iteration_data_bis'.
    try:
        # Guardar datos de iteraciones para la gráfica
        global js_iteration_data_bis
        js_data_container_bis = js_iteration_data_bis
        js_data_container_bis.clear() 
        for item_bis in iteraciones_py_bis:
            js_data_container_bis.append(item_bis)
        
        # Guardar salida HTML completa
        global pyodide_html_output
        pyodide_html_output = "\\n".join(output_buffer_bis)
    except NameError:
        # Si no estamos en Pyodide o las variables no están pre-declaradas
        print("Ejecutando localmente (Bisección), imprimiendo HTML generado:")
        print("\\n".join(output_buffer_bis))
        # print("\\nDatos de iteraciones (variable Python \'iteraciones_py_bis\'):")
        # for data_pt in iteraciones_py_bis:
        # print(data_pt)
                            </textarea>
                            <button id="run-biseccion-code-button" class="run-button mt-4 px-5 py-2.5 bg-custom-red text-white rounded-md hover:bg-red-700">Ejecutar Código</button>
                            
                            <div class="relative">
                                <div id="bis-output-controls-container" class="absolute top-0 right-0 z-10 flex items-center space-x-1 transition-all duration-500 ease-out">
                                    <button id="bis-decrease-font-button" title="Disminuir fuente" class="p-1.5 bg-gray-700 text-white rounded hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 text-xs font-semibold flex items-center justify-center" style="min-width: 30px; display: none;">
                                        aa
                                    </button>
                                    <button id="bis-increase-font-button" title="Aumentar fuente" class="p-1.5 bg-gray-700 text-white rounded hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 text-xs font-semibold flex items-center justify-center" style="min-width: 30px; display: none;">
                                        AA
                                    </button>
                                    <button id="bis-fullscreen-output-button" title="Ver en pantalla completa" class="p-1.5 bg-gray-700 text-white rounded hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 text-xs">
                                        <!-- SVG will be injected by JS -->
                                    </button>
                                </div>
                                <h4 class="mt-5 mb-2 text-lg font-semibold text-gray-700">Salida:</h4>
                                <pre id="biseccion-code-output" class="code-output bg-gray-900 text-white p-4 pt-10 rounded-md min-h-[100px] whitespace-pre-wrap transition-all duration-500 ease-out text-xs leading-relaxed max-h-96 overflow-y-auto font-mono">Presiona "Ejecutar Código" para ver la salida.</pre>
                            </div>
                        </div>
                    </section>
                    <section id="graficas" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Gráficas Interactivas</h3>
                        <p>CONTENIDO DE DESCRIPCION DE GRAFICA DE BISECCION...</p>
                        <div class="interactive-graphics w-full h-96 bg-white p-4 rounded-lg shadow-md">
                            <canvas id="biseccion-chapra-chart"></canvas>
                            <p id="chart-loading-message" class="text-center text-gray-600 italic mt-2">Cargando gráfica...</p>
                        </div>
                    </section>
                    <section id="videos" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Videos Explicativos</h3>
                        <div class="video-embed w-full h-96">
                            <!-- Ejemplo de Video de Bisección -->
                            <iframe class="w-full h-full rounded-lg shadow-lg" src="https://www.youtube.com/embed/_M3C0RfowIg" title="YouTube video player - Método de Bisección" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                        </div>
                    </section>
                    <section id="conclusion-metodo" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Conclusión y Aplicaciones</h3>
                        <p class="text-gray-600 leading-relaxed mb-4">
                            El método de bisección es garantizado para converger si se cumple la condición inicial <em>f(a) * f(b) < 0</em> 
                            y la función es continua. Su principal ventaja es su simplicidad y robustez.
                        </p>
                        <p class="text-gray-600 leading-relaxed mb-4">
                            Sin embargo, su convergencia es lineal y, por lo tanto, puede ser lenta en comparación con otros métodos como Newton-Raphson 
                            o el método de la secante, especialmente si la derivada de la función es grande cerca de la raíz.
                        </p>
                        <p class="text-gray-600 leading-relaxed mb-2 font-medium">
                            <strong>Aplicaciones:</strong>
                        </p>
                        <ul class="list-disc list-inside space-y-2 pl-4 text-gray-600 mb-4">
                            <li>Resolver ecuaciones no lineales donde no se conoce una buena aproximación inicial o la función no es bien comportada para métodos más rápidos.</li>
                            <li>Como paso inicial para refinar una raíz con un método más rápido una vez que se ha localizado un intervalo pequeño.</li>
                            <li>Encontrar puntos de cruce de funciones (resolviendo <em>f(x) - g(x) = 0</em>).</li>
                        </ul>
                    </section>
                    <section id="referencias" class="mb-10 scroll-mt-24">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Referencias</h3>
                        <ul class="list-disc list-inside space-y-2 text-gray-600 leading-relaxed pl-4">
                            <li>Chapra, S. C., & Canale, R. P. (2015). <em>Numerical Methods for Engineers</em> (7th ed.). McGraw-Hill Education. (Principalmente Capítulo 5 para el método de Bisección).</li>
                        </ul>
                    </section>
                    <section id="cuestionario" class="scroll-mt-24 mb-10">
                        <h3 class="text-2xl font-semibold mb-4 text-gray-700">Cuestionario: Método de Bisección</h3>
                        <form id="quiz-biseccion" class="space-y-6 bg-gray-50 p-6 rounded-lg shadow-inner">
                            <!-- Pregunta 1 -->
                            <div class="quiz-question space-y-2">
                                <p class="text-sm font-medium text-gray-700">1. ¿Cuál es la condición fundamental que debe cumplir un intervalo \([x_l, x_u]\) para garantizar que el método de bisección pueda encontrar una raíz?</p>
                                <fieldset class="mt-2">
                                    <legend class="sr-only">Opciones para la pregunta 1</legend>
                                    <div class="space-y-2">
                                        <label for="q1-opt1-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q1-opt1-bis" name="question-1-biseccion" type="radio" value="La función es derivable en el intervalo." class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">La función es derivable en el intervalo.</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                        <label for="q1-opt2-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q1-opt2-bis" name="question-1-biseccion" type="radio" value="La función cambia de signo en los extremos del intervalo." class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">La función cambia de signo en los extremos del intervalo.</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                        <label for="q1-opt3-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q1-opt3-bis" name="question-1-biseccion" type="radio" value="El intervalo es lo suficientemente pequeño." class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">El intervalo es lo suficientemente pequeño.</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                    </div>
                                </fieldset>
                                <div id="question-1-biseccion-specific-feedback" class="specific-question-feedback mt-2 p-2.5 text-xs bg-red-50 text-red-600 border border-red-200 rounded-md" style="display: none;"></div>
                            </div>

                            <!-- Pregunta 2 -->
                            <div class="quiz-question space-y-2">
                                <p class="text-sm font-medium text-gray-700">2. En cada iteración del método de bisección, ¿qué sucede con el tamaño del intervalo que contiene la raíz?</p>
                                <fieldset class="mt-2">
                                    <legend class="sr-only">Opciones para la pregunta 2</legend>
                                    <div class="space-y-2">
                                        <label for="q2-opt1-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q2-opt1-bis" name="question-2-biseccion" type="radio" value="Se duplica." class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">Se duplica.</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                        <label for="q2-opt2-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q2-opt2-bis" name="question-2-biseccion" type="radio" value="Se reduce a la mitad." class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">Se reduce a la mitad.</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                        <label for="q2-opt3-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q2-opt3-bis" name="question-2-biseccion" type="radio" value="Permanece igual, pero se desplaza." class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">Permanece igual, pero se desplaza.</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                    </div>
                                </fieldset>
                                <div id="question-2-biseccion-specific-feedback" class="specific-question-feedback mt-2 p-2.5 text-xs bg-red-50 text-red-600 border border-red-200 rounded-md" style="display: none;"></div>
                            </div>

                            <!-- Pregunta 3 -->
                            <div class="quiz-question space-y-2">
                                <p class="text-sm font-medium text-gray-700">3. ¿Cuál es la fórmula para calcular la nueva aproximación de la raíz (\(x_r\)) en el método de bisección?</p>
                                <fieldset class="mt-2">
                                    <legend class="sr-only">Opciones para la pregunta 3</legend>
                                    <div class="space-y-2">
                                        <label for="q3-opt1-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q3-opt1-bis" name="question-3-biseccion" type="radio" value="\\(x_r = x_u - f(x_u) * (x_l - x_u) / (f(x_l) - f(x_u))\\)" class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">\(x_r = x_u - f(x_u) * (x_l - x_u) / (f(x_l) - f(x_u))\)</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                        <label for="q3-opt2-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q3-opt2-bis" name="question-3-biseccion" type="radio" value="\\(x_r = x_l - f(x_l) / f'(x_l)\\\)" class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">\(x_r = x_l - f(x_l) / f'(x_l)\)</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                        <label for="q3-opt3-bis" class="quiz-option-wrapper flex items-center p-3 w-full rounded-md border border-gray-300 hover:border-gray-400 cursor-pointer transition-all duration-150 has-[:checked]:bg-red-50 has-[:checked]:border-custom-red has-[:checked]:ring-1 has-[:checked]:ring-custom-red">
                                            <input id="q3-opt3-bis" name="question-3-biseccion" type="radio" value="\\(x_r = (x_l + x_u) / 2\\)" class="h-4 w-4 text-custom-red border-gray-300 focus:ring-custom-red accent-custom-red">
                                            <span class="option-text ml-3 text-sm text-gray-700">\(x_r = (x_l + x_u) / 2\)</span>
                                            <span class="feedback-icon-placeholder ml-auto pl-2"><span class="inline-block w-5 h-5"></span></span>
                                        </label>
                                    </div>
                                </fieldset>
                                <div id="question-3-biseccion-specific-feedback" class="specific-question-feedback mt-2 p-2.5 text-xs bg-red-50 text-red-600 border border-red-200 rounded-md" style="display: none;"></div>
                            </div>

                            <button type="submit" class="mt-6 w-full px-6 py-3 bg-custom-red text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition-colors duration-150">
                                Enviar Respuestas
                            </button>
                        </form>
                        <div id="quiz-feedback-biseccion" class="quiz-feedback-message mt-4 p-3 rounded-md text-sm" style="display: none;"></div>
                    </section>
                </article>
            </main>

            <aside class="w-full lg:w-64 bg-sidebar-bg shadow-xl rounded-lg p-6 self-start sticky top-8 order-3 space-y-6 right-sidebar-fixed">
                <div class="pb-6 border-b border-gray-200">
                    <h3 class="text-base font-semibold text-gray-500 uppercase tracking-wide mb-4">Perfil</h3>
                    <div class="flex items-center space-x-4">
                        <div class="flex-shrink-0">
                           <svg class="w-12 h-12 text-gray-400 bg-gray-100 rounded-full p-1 ring-1 ring-gray-200" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"></path></svg>
                        </div>
                        <div>
                            <p class="font-semibold text-gray-800 text-md">Estudiante Modelo</p>
                            <p class="text-sm text-gray-500">Aprendiz Activo</p>
                        </div>
                    </div>
                </div>

                <div class="pb-6 border-b border-gray-200 space-y-3">
                    <h3 class="text-base font-semibold text-gray-500 uppercase tracking-wide">Progreso en Método de Bisección</h3>
                    
                    <ul class="space-y-2 text-sm">
                        <li class="flex items-center">
                            <span id="task-read-theory-status-bis" class="task-status-icon mr-2 text-gray-400">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            </span>
                            <span class="text-gray-600">Leer la teoría completa</span>
                        </li>
                        <li class="flex items-center">
                            <span id="task-run-code-status-bis" class="task-status-icon mr-2 text-gray-400">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            </span>
                            <span class="text-gray-600">Ejecutar el código Python</span>
                        </li>
                        <li class="flex items-center">
                            <span id="task-quiz-attempted-status-bis" class="task-status-icon mr-2 text-gray-400">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            </span>
                            <span class="text-gray-600">Intentar el cuestionario</span>
                        </li>
                        <li class="flex items-center">
                            <span id="task-quiz-passed-status-bis" class="task-status-icon mr-2 text-gray-400">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            </span>
                            <span class="text-gray-600">Aprobar el cuestionario</span>
                        </li>
                    </ul>

                    <div class="flex items-center justify-between mb-1 mt-3">
                       <span class="text-xs font-medium text-custom-red">Progreso General</span>
                       <span id="right-sidebar-progress-text-bis" class="text-xs font-medium text-custom-red right-sidebar-progress-text">0%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-3">
                        <div id="right-sidebar-progress-bar-bis" class="bg-custom-red h-3 rounded-full right-sidebar-progress-bar transition-width duration-500 ease-in-out" style="width: 0%"></div>
                    </div>
                    
                    <button id="completion-biseccion-sidebar" class="mt-4 w-full completion-button px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 font-medium text-sm transition-colors duration-150">Marcar Todo Completado</button>
                </div>

                <!-- Evaluación sección comentada -->
                <!-- 
                <div class="pb-6 border-b border-gray-200">
                    <h3 class="text-base font-semibold text-gray-500 uppercase tracking-wide mb-3">Evaluación</h3>
                    <a href="#cuestionario" class="block w-full text-center px-4 py-2 bg-custom-blue text-white rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-custom-blue focus:ring-offset-2 font-medium text-sm transition-colors duration-150">Realizar Cuestionario</a>
                </div>
                -->

                <div class="pb-6 border-b border-gray-200">
                    <h3 class="text-base font-semibold text-gray-500 uppercase tracking-wide mb-3">Recursos y Notas</h3>
                    <p class="text-sm text-gray-600">
                        <a href="https://archive.org/details/numerical-methods-for-engineers-7th-edit" target="_blank" rel="noopener noreferrer" class="hover:text-custom-red hover:underline">
                            Métodos Numéricos para Ingenieros 7ma Edición de Chapra
                        </a>
                    </p>
                    <img src="https://images.cdn3.buscalibre.com/fit-in/360x360/97/ff/97ffa61a8adb147e569e12c4f1f797b3.jpg" alt="Portada del libro Métodos Numéricos para Ingenieros de Chapra" class="mt-2 w-full rounded-md shadow-sm">
                </div>

                <div>
                    <h3 class="text-base font-semibold text-gray-500 uppercase tracking-wide mb-3">Siguiente Paso</h3>
                    <a href="/methods/regla-falsa" class="group flex items-center text-sm font-medium text-custom-red hover:text-red-700 transition-colors duration-150">
                       <span>Explorar Método de Regla Falsa</span> 
                       <svg class="w-4 h-4 ml-1 transform group-hover:translate-x-1 transition-transform duration-150" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg>
                    </a>
                </div>
            </aside>

        </div>

        <footer class="bg-custom-blue text-gray-300 text-center p-6 mt-12">
            <p>&copy; 2024 Plataforma Educativa de Métodos Numéricos. <a href="../index.html" class="hover:text-white underline">Volver al inicio</a></p>
        </footer>
    </div>

    <!--    <script src="../script.js"></script>
    
    <!-- Script para controlar el preloader -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Ocultar el preloader y mostrar el contenido cuando todo esté cargado
            window.addEventListener('load', function() {
                // Pequeña demora para asegurar que todo esté renderizado correctamente
                setTimeout(function() {
                    document.body.classList.add('loaded');
                    const preloader = document.getElementById('sidebar-preloader');
                    if (preloader) {
                        preloader.classList.add('hidden');
                    }
                }, 200);
            });
            
            // Como respaldo, si la carga tarda más de 1.5 segundos, mostrar el contenido de todos modos
            setTimeout(function() {
                document.body.classList.add('loaded');
                const preloader = document.getElementById('sidebar-preloader');
                if (preloader) {
                    preloader.classList.add('hidden');
                }
            }, 1500);
        });
    </script>
</body>
</html>

    <!-- START BIS SCRIPT -->
    <script>
    const isAuthenticatedJinjaString = "{{ (current_user is not none)|tojson }}";
window.userIsAuthenticated = JSON.parse(isAuthenticatedJinjaString || "false");
console.log("[DEBUG] isAuthenticatedJinjaString:", isAuthenticatedJinjaString);
    console.log("[DEBUG] window.userIsAuthenticated after parse:", window.userIsAuthenticated);
    
    document.addEventListener('DOMContentLoaded', () => {
        console.log("[DEBUG] USER_IS_AUTHENTICATED (inside DOMContentLoaded):", window.userIsAuthenticated);
        const USER_IS_AUTHENTICATED = window.userIsAuthenticated === true;
        console.log("[DEBUG] const USER_IS_AUTHENTICATED evaluated to:", USER_IS_AUTHENTICATED);

        // --- START: Fullscreen and Font Control Logic for Code Output (Adapted from Serie Taylor) ---
        const fullscreenButton_BIS = document.getElementById('bis-fullscreen-output-button');
        const codeOutput_BIS = document.getElementById('biseccion-code-output'); // Corrected ID for biseccion
        const outputControlsContainer_BIS = document.getElementById('bis-output-controls-container');

        const increaseFontButton_BIS = document.getElementById('bis-increase-font-button');
        const decreaseFontButton_BIS = document.getElementById('bis-decrease-font-button');
        let originalOutputFontSize_BIS = '';
        const MIN_FONT_SIZE_PX_BIS = 8;
        const MAX_FONT_SIZE_PX_BIS = 28;
        const FONT_SIZE_STEP_PX_BIS = 1;
        let bisCodeOutputInitialRect = null; // To store initial state for flip-like effect

        // Set initial icon for the fullscreen button
        if (fullscreenButton_BIS) {
            fullscreenButton_BIS.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75v4.5m0-4.5h-4.5m4.5 0L15 9m5.25 11.25v-4.5m0 4.5h-4.5m4.5 0L15 15" />
                </svg>`;
            fullscreenButton_BIS.title = "Ver en pantalla completa";
        }

        // Listener for the fullscreen button of the code output
        if (fullscreenButton_BIS && codeOutput_BIS && outputControlsContainer_BIS) {
            fullscreenButton_BIS.addEventListener('click', () => {
                const isFullscreen = codeOutput_BIS.classList.contains('bis-output-fullscreen');
                
                if (isFullscreen) {
                    // === EXITING FULLSCREEN ===
                    outputControlsContainer_BIS.style.opacity = '0'; // Fade out container FIRST
                    if(increaseFontButton_BIS) increaseFontButton_BIS.style.display = 'none'; // Hide buttons immediately
                    if(decreaseFontButton_BIS) decreaseFontButton_BIS.style.display = 'none';

                    if (bisCodeOutputInitialRect) {
                        const finalRect = codeOutput_BIS.getBoundingClientRect(); 
                        const scaleX = bisCodeOutputInitialRect.width / finalRect.width;
                        const scaleY = bisCodeOutputInitialRect.height / finalRect.height;
                        const deltaX = (bisCodeOutputInitialRect.left + bisCodeOutputInitialRect.width / 2) - (finalRect.left + finalRect.width / 2);
                        const deltaY = (bisCodeOutputInitialRect.top + bisCodeOutputInitialRect.height / 2) - (finalRect.top + finalRect.height / 2);
                        codeOutput_BIS.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`;
                    }

                    setTimeout(() => {
                        codeOutput_BIS.style.transition = 'none'; 
                        codeOutput_BIS.classList.remove('bis-output-fullscreen');
                        document.body.classList.remove('bis-body-fullscreen-active');
                        
                        outputControlsContainer_BIS.classList.remove('bis-output-controls-container-fixed');
                        outputControlsContainer_BIS.style.transition = 'none'; 
                        outputControlsContainer_BIS.style.opacity = '1';     
                        outputControlsContainer_BIS.offsetHeight; 
                        outputControlsContainer_BIS.style.transition = '';   

                        codeOutput_BIS.style.transform = '';
                        if (originalOutputFontSize_BIS) {
                            codeOutput_BIS.style.fontSize = originalOutputFontSize_BIS;
                        }
                        codeOutput_BIS.offsetHeight; 
                        codeOutput_BIS.style.transition = ''; 

                        fullscreenButton_BIS.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75v4.5m0-4.5h-4.5m4.5 0L15 9m5.25 11.25v-4.5m0 4.5h-4.5m4.5 0L15 15" />
                            </svg>`;
                        fullscreenButton_BIS.title = "Ver en pantalla completa";
                        bisCodeOutputInitialRect = null; 
                    }, 500); 

                } else {
                    // === ENTERING FULLSCREEN ===
                    originalOutputFontSize_BIS = window.getComputedStyle(codeOutput_BIS).fontSize;
                    bisCodeOutputInitialRect = codeOutput_BIS.getBoundingClientRect(); 
                    
                    outputControlsContainer_BIS.style.transition = 'none'; 
                    outputControlsContainer_BIS.style.opacity = '0';     
                    outputControlsContainer_BIS.offsetHeight; 
                    outputControlsContainer_BIS.style.transition = '';   

                    if(increaseFontButton_BIS) increaseFontButton_BIS.style.display = 'none';
                    if(decreaseFontButton_BIS) decreaseFontButton_BIS.style.display = 'none';
                    
                    codeOutput_BIS.style.transition = 'none'; 
                    codeOutput_BIS.classList.add('bis-output-fullscreen');
                    document.body.classList.add('bis-body-fullscreen-active');
                    outputControlsContainer_BIS.classList.add('bis-output-controls-container-fixed'); 
                    
                    const finalRect = codeOutput_BIS.getBoundingClientRect(); 
                    const scaleX = bisCodeOutputInitialRect.width / finalRect.width;
                    const scaleY = bisCodeOutputInitialRect.height / finalRect.height;
                    const deltaX = (bisCodeOutputInitialRect.left + bisCodeOutputInitialRect.width / 2) - (finalRect.left + finalRect.width / 2);
                    const deltaY = (bisCodeOutputInitialRect.top + bisCodeOutputInitialRect.height / 2) - (finalRect.top + finalRect.height / 2);
                    codeOutput_BIS.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${scaleX}, ${scaleY})`;
                    
                    codeOutput_BIS.offsetHeight; 
                    codeOutput_BIS.style.transition = ''; 
                    codeOutput_BIS.style.transform = 'translate(0px, 0px) scale(1)'; 

                    fullscreenButton_BIS.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9V4.5M15 9h4.5M15 9l5.25-5.25M15 15v4.5M15 15h4.5M15 15l5.25 5.25" />
                        </svg>`;
                    fullscreenButton_BIS.title = "Salir de pantalla completa";
                    
                    setTimeout(() => {
                        outputControlsContainer_BIS.style.opacity = '1'; // Ensure container is visible
                        if(increaseFontButton_BIS) increaseFontButton_BIS.style.display = 'flex';
                        if(decreaseFontButton_BIS) decreaseFontButton_BIS.style.display = 'flex';
                    }, 500); 
                }
            });
        }

        // Listeners for font size buttons
        if (increaseFontButton_BIS && codeOutput_BIS) {
            increaseFontButton_BIS.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent click from bubbling to parent elements
                const currentSize = parseFloat(window.getComputedStyle(codeOutput_BIS).fontSize);
                if (currentSize < MAX_FONT_SIZE_PX_BIS) {
                    codeOutput_BIS.style.fontSize = `${Math.min(currentSize + FONT_SIZE_STEP_PX_BIS, MAX_FONT_SIZE_PX_BIS)}px`;
                }
                increaseFontButton_BIS.classList.add('bis-font-button-flash-blue');
                setTimeout(() => increaseFontButton_BIS.classList.remove('bis-font-button-flash-blue'), 400);
            });
        }
        if (decreaseFontButton_BIS && codeOutput_BIS) {
            decreaseFontButton_BIS.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentSize = parseFloat(window.getComputedStyle(codeOutput_BIS).fontSize);
                if (currentSize > MIN_FONT_SIZE_PX_BIS) {
                    codeOutput_BIS.style.fontSize = `${Math.max(currentSize - FONT_SIZE_STEP_PX_BIS, MIN_FONT_SIZE_PX_BIS)}px`;
                }
                decreaseFontButton_BIS.classList.add('bis-font-button-flash-red');
                setTimeout(() => decreaseFontButton_BIS.classList.remove('bis-font-button-flash-red'), 400);
            });
        }
        // --- END: Fullscreen and Font Control Logic for Code Output ---

        const PAGE_KEY_BIS = 'biseccion';
        const QUIZ_FORM_ID_BIS = 'quiz-biseccion';
        const QUIZ_FEEDBACK_ID_BIS = 'quiz-feedback-biseccion';
        const COMPLETION_BUTTON_ID_BIS = 'completion-biseccion-sidebar';
        const CODE_INPUT_ID_BIS = 'biseccion-code-input';
        const CODE_OUTPUT_ID_BIS = 'biseccion-code-output';
        const RUN_CODE_BUTTON_ID_BIS = 'run-biseccion-code-button';
        const CHART_CANVAS_ID_BIS = 'biseccion-chapra-chart';
        const CHART_LOADING_MESSAGE_ID_BIS = 'chart-loading-message';

        const TASKS_BIS = {
            READ_THEORY: 'read_theory',
            RUN_CODE: 'run_code',
            QUIZ_ATTEMPTED: 'quiz_attempted',
            QUIZ_PASSED: 'quiz_passed'
        };
        const ALL_TASK_KEYS_BIS = Object.values(TASKS_BIS);
        const TOTAL_TASKS_BIS = ALL_TASK_KEYS_BIS.length;

        const ICON_PENDING_BIS = '<svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0-4.418-4.03-8-9-8S3 7.582 3 12c0 1.454.402 2.813 1.098 3.977L3 21l5.023-1.098A8.902 8.902 0 0012 21c4.97 0 9-3.582 9-9z"></path></svg>';
        const ICON_COMPLETED_BIS = '<svg class="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>';
        const ICON_IN_PROGRESS_BIS = '<svg class="w-5 h-5 text-yellow-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V9.05a.75.75 0 011.307-.588l5.603 3.112z" clip-rule="evenodd"></path></svg>';
        const ICON_CORRECT_ANSWER_BIS = '✔️'; // Usar emoji directamente
        const ICON_INCORRECT_ANSWER_BIS = '❌'; // Usar emoji directamente
        const ICON_THUMB_UP_BIS = '👍'; // Icono para la respuesta correcta cuando el usuario falla

        const quizDataBiseccion = {
            "question-1-biseccion": {
                correctAnswer: "La función cambia de signo en los extremos del intervalo.",
                feedback: {
                    "La función es derivable en el intervalo.": "Si bien la continuidad es importante (implicada por el cambio de signo en una función continua), la derivabilidad no es un requisito fundamental para la bisección.",
                    "El intervalo es lo suficientemente pequeño.": "Un intervalo pequeño es el objetivo, no la condición inicial para aplicar el método.",
                }
            },
            "question-2-biseccion": {
                correctAnswer: "Se reduce a la mitad.",
                feedback: {
                    "Se duplica.": "Incorrecto. El método busca acotar la raíz, no ampliar el intervalo.",
                    "Permanece igual, pero se desplaza.": "Incorrecto. El tamaño del intervalo se reduce consistentemente.",
                }
            },
            "question-3-biseccion": {
                correctAnswer: "\\\\(x_r = (x_l + x_u) / 2\\\\)", // Escapar las barras para que el string en memoria sea \\( y coincida con el value del HTML
                feedback: {
                    "\\\\(x_r = x_u - f(x_u) * (x_l - x_u) / (f(x_l) - f(x_u))\\\\)": "Esta es la fórmula para el método de la Regla Falsa.",
                    "\\\\(x_r = x_l - f(x_l) / f'(x_l)\\\\)": "Esta es la fórmula para el método de Newton-Raphson.",
                }
            }
        };

        let pyodide_BIS = null;
        let methodChart_BIS = null;
        const mainCompletionButton_BIS = document.getElementById(COMPLETION_BUTTON_ID_BIS);
        const quizForm_BIS = document.getElementById(QUIZ_FORM_ID_BIS);
        const generalQuizFeedbackDiv_BIS = document.getElementById(QUIZ_FEEDBACK_ID_BIS);
        const codeInput_BIS = document.getElementById(CODE_INPUT_ID_BIS);
        const runCodeButton_BIS = document.getElementById(RUN_CODE_BUTTON_ID_BIS);
        const chartCanvas_BIS = document.getElementById(CHART_CANVAS_ID_BIS);
        const chartLoadingMessage_BIS = document.getElementById(CHART_LOADING_MESSAGE_ID_BIS);

        const taskStatusIcons_BIS = {
            [TASKS_BIS.READ_THEORY]: document.getElementById('task-read-theory-status-bis'),
            [TASKS_BIS.RUN_CODE]: document.getElementById('task-run-code-status-bis'),
            [TASKS_BIS.QUIZ_ATTEMPTED]: document.getElementById('task-quiz-attempted-status-bis'),
            [TASKS_BIS.QUIZ_PASSED]: document.getElementById('task-quiz-passed-status-bis'),
        };
        const overallProgressText_BIS = document.getElementById('right-sidebar-progress-text-bis');
        const overallProgressBar_BIS = document.getElementById('right-sidebar-progress-bar-bis');

        async function getPageProgressFromStorage_BIS(pKey) {
            const defaults = {
                [TASKS_BIS.READ_THEORY]: false,
                [TASKS_BIS.RUN_CODE]: false,
                [TASKS_BIS.QUIZ_ATTEMPTED]: false,
                [TASKS_BIS.QUIZ_PASSED]: false,
                overall_progress: 0,
                user_quiz_answers: {},
                quiz_current_score: 0,
                quiz_feedback_active: false
            };

            // Primero intentamos obtener el progreso del servidor si el usuario está autenticado
            if (USER_IS_AUTHENTICATED) {
                try {
                    const response = await fetch(`/api/load_progress/${pKey}`);
                    if (!response.ok) {
                        console.warn(`Error al cargar progreso del servidor para ${pKey}: ${response.status}`);
                        // Si hay error, continuamos con localStorage como fallback
                    } else {
                        const serverResponse = await response.json();
                        console.log("[GET PROGRESS DEBUG] Raw serverResponse from API:", JSON.stringify(serverResponse));
                        
                        // Extraer el objeto progress del objeto response
                        const progressData = serverResponse.progress || {};
                        console.log("[GET PROGRESS DEBUG] Extracted progress data:", JSON.stringify(progressData));
                        
                        if (progressData && typeof progressData === 'object' && Object.keys(progressData).length > 0) {
                            console.log(`[GET PROGRESS DEBUG] Progreso cargado del servidor para ${pKey}:`, progressData);
                            // Limpieza de datos para evitar problemas con valores antiguos
                            const cleanedServerProgress = { ...defaults, ...progressData };
                            return cleanedServerProgress;
                        } else {
                            // Si la API devuelve ok pero el progreso está vacío (ej. nuevo usuario), 
                            // devolvemos los defaults y NO recurrimos a localStorage.
                            console.log(`[GET PROGRESS DEBUG] Server progress for ${pKey} is empty/invalid. Returning defaults. Not falling back to localStorage.`);
                            return defaults;
                        }
                    }
                } catch (e) {
                    console.error(`Error en fetch al cargar progreso para ${pKey}:`, e);
                    // En caso de error de red en el fetch, recurriremos a localStorage
                }
            }

            // Fallback a localStorage SOLO si !USER_IS_AUTHENTICATED o si el fetch de arriba falló
            console.log("[GET PROGRESS DEBUG] Attempting localStorage fallback for " + pKey + " (User Authenticated: " + USER_IS_AUTHENTICATED + ")");
            try {
                const stored = localStorage.getItem(pKey);
                if (stored) {
                    const localProgress = JSON.parse(stored);
                    console.log("[GET PROGRESS DEBUG] Cleaned localStorage progress:", JSON.stringify(localProgress));
                    return { ...defaults, ...localProgress };
                }
            } catch (e) { console.error("Error al leer localStorage para BIS:", e); }
            
            console.log("[GET PROGRESS DEBUG] Returning pure defaults as no server or valid local progress found.");
            return defaults;
        }

        async function savePageProgressToStorage_BIS(pKey, progress) {
            if (USER_IS_AUTHENTICATED) {
                try {
                    const response = await fetch('/api/save_progress', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ page_key: pKey, progress_data: progress }),
                    });
                    if (response.ok) {
                        console.log(`Progreso guardado en servidor para ${pKey}`);
                    } else {
                        console.warn(`Error al guardar progreso en servidor para ${pKey}: ${response.status}`);
                    }
                } catch (e) {
                    console.error(`Error en fetch al guardar progreso para ${pKey}:`, e);
                }
            }

            // Guardar siempre en localStorage como respaldo o para modo offline
            try {
                localStorage.setItem(pKey, JSON.stringify(progress));
                window.dispatchEvent(new CustomEvent('bisPageProgressSaved', { detail: { pageKey: pKey, progress } }));
            } catch (e) { console.error("Error al guardar en localStorage para BIS:", e); }
        }

        async function updateTaskStatusInStorage_BIS(taskName, isCompleted) {
            let currentProgress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
            if (currentProgress.hasOwnProperty(taskName) && currentProgress[taskName] !== isCompleted) {
                currentProgress[taskName] = isCompleted;
                if (taskName === TASKS_BIS.QUIZ_ATTEMPTED && !isCompleted) {
                    currentProgress[TASKS_BIS.QUIZ_PASSED] = false;
                    currentProgress.user_quiz_answers = {};
                    currentProgress.quiz_current_score = 0;
                    currentProgress.quiz_feedback_active = false;
                }
                // Si se desmarca "aprobado" (y no es por desmarcar "intentado")
                if (taskName === TASKS_BIS.QUIZ_PASSED && !isCompleted && currentProgress[TASKS_BIS.QUIZ_ATTEMPTED]) {
                    // No limpiar respuestas, pero sí el estado de feedback activo si no hay un intento nuevo
                } else if (taskName === TASKS_BIS.QUIZ_PASSED && !isCompleted) {
                     currentProgress.user_quiz_answers = {};
                     currentProgress.quiz_current_score = 0;
                }
                await savePageProgressToStorage_BIS(PAGE_KEY_BIS, currentProgress);
                await calculateAndUpdateOverallProgress_BIS();
            }
        }

        async function renderTaskStatus_BIS() {
            const progress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
            ALL_TASK_KEYS_BIS.forEach(taskKey => {
                const iconElement = taskStatusIcons_BIS[taskKey];
                if (iconElement) {
                    let newIconHTML = ICON_PENDING_BIS;
                    if (progress[taskKey]) {
                        newIconHTML = ICON_COMPLETED_BIS;
                    } else if (taskKey === TASKS_BIS.QUIZ_PASSED && progress[TASKS_BIS.QUIZ_ATTEMPTED]) {
                        newIconHTML = ICON_IN_PROGRESS_BIS;
                    }
                    iconElement.innerHTML = newIconHTML;
                }
            });
        }

        async function calculateAndUpdateOverallProgress_BIS() {
            let progress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
            console.log("[CALC DEBUG] Progress object received by calculateAndUpdateOverallProgress_BIS:", JSON.stringify(progress));
            
            let completedTasks = ALL_TASK_KEYS_BIS.filter(taskKey => progress[taskKey]).length;
            const percentage = TOTAL_TASKS_BIS > 0 ? (completedTasks / TOTAL_TASKS_BIS) * 100 : 0;
            progress.overall_progress = percentage;
            await savePageProgressToStorage_BIS(PAGE_KEY_BIS, progress);

            const isHundredPercent = percentage.toFixed(0) === '100';
            if (overallProgressBar_BIS) {
                overallProgressBar_BIS.style.width = `${percentage.toFixed(0)}%`;
                overallProgressBar_BIS.classList.toggle('animate-rainbow-border', isHundredPercent);
            }
            if (overallProgressText_BIS) overallProgressText_BIS.textContent = `${percentage.toFixed(0)}%`;
            
            await renderTaskStatus_BIS();
            await updateMainCompletionButtonState_BIS();
        }

        async function handleMarkAllMouseEnter_BIS() {
            if (mainCompletionButton_BIS && mainCompletionButton_BIS.dataset.isUndo === "true") {
                mainCompletionButton_BIS.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                mainCompletionButton_BIS.classList.add('bg-red-600', 'hover:bg-red-700');
            }
        }

        async function handleMarkAllMouseLeave_BIS() {
            if (mainCompletionButton_BIS && mainCompletionButton_BIS.dataset.isUndo === "true") {
                mainCompletionButton_BIS.classList.remove('bg-red-600', 'hover:bg-red-700');
                mainCompletionButton_BIS.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            }
        }

        async function updateMainCompletionButtonState_BIS() {
            if (!mainCompletionButton_BIS) return;
            const progress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
            let allTasksCompleted = ALL_TASK_KEYS_BIS.every(task => progress[task] === true);
            
            mainCompletionButton_BIS.removeEventListener('mouseenter', handleMarkAllMouseEnter_BIS);
            mainCompletionButton_BIS.removeEventListener('mouseleave', handleMarkAllMouseLeave_BIS);
            mainCompletionButton_BIS.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-yellow-500', 'hover:bg-yellow-600', 'bg-red-600', 'hover:bg-red-700', 'opacity-50', 'cursor-not-allowed');
            mainCompletionButton_BIS.disabled = false;

            if (allTasksCompleted) {
                mainCompletionButton_BIS.textContent = 'Deshacer Completado';
                mainCompletionButton_BIS.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                mainCompletionButton_BIS.dataset.isUndo = "true";
                mainCompletionButton_BIS.addEventListener('mouseenter', handleMarkAllMouseEnter_BIS);
                mainCompletionButton_BIS.addEventListener('mouseleave', handleMarkAllMouseLeave_BIS);
            } else {
                mainCompletionButton_BIS.textContent = 'Marcar Todo Completado';
                mainCompletionButton_BIS.classList.add('bg-green-600', 'hover:bg-green-700');
                mainCompletionButton_BIS.dataset.isUndo = "false";
            }
        }
        
        async function clearAllVisualFeedback_BIS(clearGeneralMessage = false) {
            if (!quizForm_BIS) return;
            quizForm_BIS.querySelectorAll('.quiz-option-wrapper').forEach(wrapper => {
                wrapper.classList.remove('correct-answer-biseccion', 'incorrect-answer-biseccion', 'border-green-500', 'border-red-500', 'ring-1', 'ring-green-500', 'ring-red-500', 'bg-green-50', 'bg-red-50');
                wrapper.classList.add('border-gray-300', 'hover:border-gray-400');
                wrapper.classList.add('has-[:checked]:bg-red-50', 'has-[:checked]:border-custom-red', 'has-[:checked]:ring-1', 'has-[:checked]:ring-custom-red');

                const iconPlaceholder = wrapper.querySelector('.feedback-icon-placeholder span');
                if (iconPlaceholder) iconPlaceholder.innerHTML = '';
            });
            quizForm_BIS.querySelectorAll('.specific-question-feedback').forEach(el => {
                el.textContent = '';
                el.style.display = 'none';
            });
            if (clearGeneralMessage && generalQuizFeedbackDiv_BIS) {
                generalQuizFeedbackDiv_BIS.textContent = '';
                generalQuizFeedbackDiv_BIS.style.display = 'none';
                generalQuizFeedbackDiv_BIS.className = 'quiz-feedback-message mt-4 p-3 rounded-md text-sm';
            }
        }

        async function displayQuizFeedback_BIS() {
            if (!quizForm_BIS || !generalQuizFeedbackDiv_BIS) return;
            const progress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
            const userAnswers = progress.user_quiz_answers || {};
            const submitButton = quizForm_BIS.querySelector('button[type="submit"]');

            await clearAllVisualFeedback_BIS(false); 

            if (!progress.quiz_feedback_active && Object.keys(userAnswers).length === 0) {
                quizForm_BIS.querySelectorAll('input[type="radio"]').forEach(radio => radio.disabled = false);
                if (submitButton) {
                    submitButton.textContent = 'Enviar Respuestas';
                    submitButton.disabled = false;
                }
                return;
            }
            
            let allCorrect = true;
            let score = 0;

            for (const questionName in quizDataBiseccion) {
                const userAnswer = userAnswers[questionName];
                const questionData = quizDataBiseccion[questionName];
                const correctAnswer = questionData.correctAnswer;
                const specificFeedbackDiv = document.getElementById(`${questionName}-specific-feedback`);

                const radioInputs = quizForm_BIS.querySelectorAll(`input[name="${questionName}"]`);
                radioInputs.forEach(input => {
                    const wrapper = input.closest('.quiz-option-wrapper');
                    const iconPlaceholder = wrapper.querySelector('.feedback-icon-placeholder span');
                    input.disabled = true; 
                    
                    // Remove Tailwind's default checked state styling before applying custom feedback
                    wrapper.classList.remove('has-[:checked]:bg-red-50', 'has-[:checked]:border-custom-red', 'has-[:checked]:ring-1', 'has-[:checked]:ring-custom-red');
                    
                    if (input.value === userAnswer) {
                        input.checked = true;
                        if (userAnswer === correctAnswer) {
                            wrapper.classList.add('correct-answer-biseccion', 'border-green-500', 'ring-1', 'ring-green-500', 'bg-green-50');
                            if (iconPlaceholder) iconPlaceholder.textContent = ICON_CORRECT_ANSWER_BIS; // Usar textContent para emojis
                            score++;
                        } else { // Usuario seleccionó ESTA opción, y es INCORRECTA
                            wrapper.classList.add('incorrect-answer-biseccion', 'border-red-500', 'ring-1', 'ring-red-500', 'bg-red-50');
                            if (iconPlaceholder) iconPlaceholder.textContent = ICON_INCORRECT_ANSWER_BIS; // Usar textContent para emojis
                            allCorrect = false;
                            if (specificFeedbackDiv && questionData.feedback && questionData.feedback[userAnswer]) {
                                specificFeedbackDiv.textContent = "Incorrecto. " + questionData.feedback[userAnswer];
                                specificFeedbackDiv.style.display = 'block';
                            } else if (specificFeedbackDiv) { // Fallback if specific feedback for chosen wrong answer isn't there
                                specificFeedbackDiv.textContent = "Incorrecto. Respuesta incorrecta.";
                                specificFeedbackDiv.style.display = 'block';
                            }
                        }
                    } else if (input.value === correctAnswer) { // Opción NO seleccionada por el usuario, PERO ES LA CORRECTA
                         wrapper.classList.add('correct-answer-biseccion', 'border-green-500', 'bg-green-50'); // Highlight correct answer if not chosen
                         // Mostrar pulgar arriba solo si el usuario efectivamente se equivocó en esta pregunta
                         if (userAnswer !== correctAnswer) {
                            if (iconPlaceholder) iconPlaceholder.textContent = ICON_THUMB_UP_BIS;
                         }
                    } else { // Opción NO seleccionada por el usuario, Y NO ES LA CORRECTA
                         wrapper.classList.add('border-gray-300');
                    }
                });
            }

            progress.quiz_current_score = score;
            await savePageProgressToStorage_BIS(PAGE_KEY_BIS, progress);

            generalQuizFeedbackDiv_BIS.style.display = 'block';
            if (allCorrect) {
                generalQuizFeedbackDiv_BIS.className = 'mt-4 p-3 rounded-md text-sm bg-green-100 text-green-700 border border-green-200';
                generalQuizFeedbackDiv_BIS.innerHTML = `<strong>¡Felicidades!</strong> Todas tus respuestas son correctas. (${score}/${Object.keys(quizDataBiseccion).length})`;
                if (submitButton) {
                    submitButton.textContent = 'Cuestionario Aprobado';
                    submitButton.disabled = true;
                }
                await updateTaskStatusInStorage_BIS(TASKS_BIS.QUIZ_PASSED, true);
            } else {
                generalQuizFeedbackDiv_BIS.className = 'mt-4 p-3 rounded-md text-sm bg-red-100 text-red-700 border border-red-200';
                generalQuizFeedbackDiv_BIS.innerHTML = `Has respondido correctamente ${score} de ${Object.keys(quizDataBiseccion).length} preguntas. Revisa los comentarios e intenta de nuevo.`;
                if (submitButton) {
                    submitButton.textContent = 'Intentar de Nuevo';
                    submitButton.disabled = false;
                }
                 await updateTaskStatusInStorage_BIS(TASKS_BIS.QUIZ_PASSED, false);
            }

            // Pedir a MathJax que reprocese el formulario del cuestionario para renderizar LaTeX
            if (window.MathJax && window.MathJax.typesetPromise && quizForm_BIS) {
                window.MathJax.typesetPromise([quizForm_BIS]).catch(function (err) {
                    console.error('Error al reprocesar MathJax en el cuestionario:', err);
                });
            }
        }
        
        async function initializePyodide_BIS() {
            // Use a more unique global variable name to avoid conflicts if other pages also use a global pyodide instance
            if (!window.pyodideInstance_BIS_Global) {
                if (codeOutput_BIS) codeOutput_BIS.innerHTML = "<p>Cargando Pyodide y entorno... (Paso 1)</p>"; // More specific initial message
                try {
                    console.log("[BIS] Iniciando carga de Pyodide...");
                    if (codeOutput_BIS) codeOutput_BIS.innerHTML = "<p>Llamando a loadPyodide()...</p>";
                    
                    window.pyodideInstance_BIS_Global = await window.loadPyodide({
                        // Optional: Add indexURL if needed, though usually not for standard CDN.
                        // indexURL: "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/"
                    });
                    console.log("[BIS] loadPyodide() completado.");
                    if (codeOutput_BIS) codeOutput_BIS.innerHTML = "<p>Pyodide cargado. Cargando paquetes...</p>";

                    await window.pyodideInstance_BIS_Global.loadPackage("micropip");
                    console.log("[BIS] Paquete micropip cargado.");
                    if (codeOutput_BIS) codeOutput_BIS.innerHTML = "<p>Paquetes cargados. Configurando globales...</p>";

                    window.pyodideInstance_BIS_Global.globals.set("js_iteration_data_bis", window.pyodideInstance_BIS_Global.toPy([]));
                    window.pyodideInstance_BIS_Global.globals.set("pyodide_html_output", "");
                    console.log("[BIS] Globales de Pyodide configurados.");

                    if (codeOutput_BIS) codeOutput_BIS.innerHTML = "<p>Pyodide listo. Presiona 'Ejecutar Código'.</p>";
                    console.log("[BIS] Pyodide específico para Bisección cargado y configurado.");
                    if (runCodeButton_BIS) runCodeButton_BIS.disabled = false;
                } catch (error) {
                    console.error("[BIS] Error al cargar/configurar Pyodide para Bisección:", error);
                    if (codeOutput_BIS) codeOutput_BIS.innerHTML = `<p style="color:red;">Error al cargar Pyodide. Revisa la consola: ${error.message}</p>`;
                    if (runCodeButton_BIS) runCodeButton_BIS.disabled = true;
                    // Ensure window.pyodideInstance_BIS_Global is not partially set if error occurs after assignment
                    window.pyodideInstance_BIS_Global = null; 
                    return null;
                }
            } else {
                 console.log("[BIS] Pyodide ya estaba cargado (window.pyodideInstance_BIS_Global existe).");
                 if (runCodeButton_BIS) runCodeButton_BIS.disabled = false;
            }
            return window.pyodideInstance_BIS_Global;
        }

        async function runCodeNow_BIS() {
            pyodide_BIS = await initializePyodide_BIS();
            if (!pyodide_BIS) { 
                if (codeOutput_BIS) codeOutput_BIS.innerHTML = "<p>Pyodide no está listo. Intenta recargar.</p>"; // Use innerHTML
                return; 
            }
            if (!codeInput_BIS || !codeOutput_BIS) return;

            const pythonCode = codeInput_BIS.value;
            if (codeOutput_BIS) codeOutput_BIS.innerHTML = "<p>Ejecutando código...</p>"; // Use innerHTML
            if (chartLoadingMessage_BIS) chartLoadingMessage_BIS.textContent = "Generando datos para la gráfica...";
            if (chartCanvas_BIS) chartCanvas_BIS.style.display = 'none';


            try {
                // Reiniciar las variables globales en Pyodide antes de cada ejecución
                pyodide_BIS.globals.set("pyodide_html_output", "");
                pyodide_BIS.runPython("if 'js_iteration_data_bis' in globals(): js_iteration_data_bis.clear()");
                
                // No necesitamos capturar stdout/stderr aquí si el Python genera HTML directamente
                pyodide_BIS.setStdout({}); 
                pyodide_BIS.setStderr({});
                
                await pyodide_BIS.loadPackagesFromImports(pythonCode);
                await pyodide_BIS.runPythonAsync(pythonCode); 
                
                // Obtener el HTML generado desde la variable global de Pyodide
                const htmlResult = pyodide_BIS.globals.get("pyodide_html_output");
                if (codeOutput_BIS) {
                    codeOutput_BIS.innerHTML = htmlResult || "<p>Ejecución completada. No se generó salida HTML.</p>";
                }
                
                // Obtener datos para la gráfica
                const iterationDataJS_BIS = pyodide_BIS.globals.get("js_iteration_data_bis").toJs({ dict_converter: Object.fromEntries });

                updateTaskStatusInStorage_BIS(TASKS_BIS.RUN_CODE, true);

                if (chartCanvas_BIS) {
                    if (iterationDataJS_BIS && iterationDataJS_BIS.length > 0) {
                        await drawChartJsGraph_BIS(iterationDataJS_BIS); // Pasar los datos directamente
                        if (chartLoadingMessage_BIS) chartLoadingMessage_BIS.style.display = 'none';
                        chartCanvas_BIS.style.display = 'block';
                    } else {
                        if (chartLoadingMessage_BIS) {
                             chartLoadingMessage_BIS.textContent = "No se generaron datos suficientes para la gráfica.";
                             chartLoadingMessage_BIS.style.display = 'block';
                        }
                        if (methodChart_BIS && typeof methodChart_BIS.destroy === 'function') methodChart_BIS.destroy();
                    }
                }

            } catch (error) { 
                if (codeOutput_BIS) {
                    codeOutput_BIS.innerHTML = `<p style="color:red;">Error en la ejecución: ${error.message || String(error)}</p>`; // Use innerHTML
                }
                if (chartLoadingMessage_BIS) chartLoadingMessage_BIS.textContent = "Error al generar datos para la gráfica.";
                console.error("Error en runCodeNow_BIS:", error);
            } finally {
                // Reset stdout/stderr to avoid interference
                pyodide_BIS.setStdout({}); 
                pyodide_BIS.setStderr({});
            }
        }

        async function drawChartJsGraph_BIS(iterationDataForChart) { // Aceptar datos como argumento
            // pyodide_BIS = await initializePyodide_BIS(); // Pyodide ya debería estar inicializado por runCodeNow_BIS
            if (!pyodide_BIS) { if(chartLoadingMessage_BIS) chartLoadingMessage_BIS.textContent = 'Pyodide no listo.'; return; }
            if (!chartCanvas_BIS) { console.error("Elemento Canvas no encontrado para la gráfica de Bisección."); return; }
            
            // No necesitamos ejecutar Python aquí si los datos ya fueron procesados y pasados
            // Solo necesitamos 'funcion_ejemplo', 'a_intervalo', 'b_intervalo' del scope global de Pyodide
            // y los datos de iteraciones ya están en 'iterationDataForChart'

            try {
                if(chartLoadingMessage_BIS) chartLoadingMessage_BIS.textContent = 'Generando gráfica de Bisección...';
                
                const func_to_plot_py = pyodide_BIS.globals.get('funcion_ejemplo');
                const current_a_py = pyodide_BIS.globals.get('a_intervalo');
                const current_b_py = pyodide_BIS.globals.get('b_intervalo');
                const final_root_val_py = pyodide_BIS.globals.get('raiz_aproximada');


                if (!func_to_plot_py) {
                    if(chartLoadingMessage_BIS) chartLoadingMessage_BIS.textContent = "Función 'funcion_ejemplo' no definida en Python.";
                    return;
                }

                // Generar puntos para f(x) usando la función de Pyodide
                const x_min_plot = (typeof current_a_py === 'number' ? current_a_py : 0.0) - 1.0;
                const x_max_plot = (typeof current_b_py === 'number' ? current_b_py : 2.0) + 1.0;
                const num_points_func = 200;
                const x_func_vals = Array.from({length: num_points_func}, (_, i) => x_min_plot + i * (x_max_plot - x_min_plot) / (num_points_func - 1));
                const y_func_vals = x_func_vals.map(x => {
                    try { return func_to_plot_py(x); }
                    catch (e) { console.warn(`Error evaluando f(${x}) para la gráfica: ${e}`); return null; }
                }).filter(y => typeof y === 'number'); // Filtrar posibles nulls si la función falla

                const valid_iterations_data = iterationDataForChart.filter(item => 
                    item && typeof item.c === 'number' && typeof item.a === 'number' && typeof item.b === 'number'
                );

                const final_root_val = (typeof final_root_val_py === 'number') ? final_root_val_py : 
                                       (valid_iterations_data.length > 0 ? valid_iterations_data[valid_iterations_data.length - 1].c : null);


                if (methodChart_BIS && typeof methodChart_BIS.destroy === 'function') {
                    methodChart_BIS.destroy();
                }
                const ctx_bis = chartCanvas_BIS.getContext('2d');
                
                const datasets_bis = [];
                if (x_func_vals.length === y_func_vals.length && y_func_vals.length > 0) {
                    datasets_bis.push({
                        label: 'f(x)',
                        data: x_func_vals.map((val, index) => ({x: val, y: y_func_vals[index]})),
                        borderColor: 'rgb(54, 162, 235)', borderWidth: 2, fill: false, tension: 0.1, type: 'line', order: 1,
                        pointRadius: 0 // No mostrar puntos para la curva de la función
                    });
                }

                if (valid_iterations_data.length > 0) {
                    datasets_bis.push({
                        label: 'Estimaciones Raíz (c)',
                        data: valid_iterations_data.map(iter => ({x: iter.c, y: 0})),
                        backgroundColor: 'rgb(255, 99, 132)', pointRadius: 5, showLine: false, type: 'scatter', order: 2
                    });
                    
                    const iterCount = valid_iterations_data.length;
                    const indicesToShow = Array.from(new Set([0, Math.floor(iterCount / 2), iterCount - 1].filter(i => i < iterCount && valid_iterations_data[i])));
                    
                    indicesToShow.forEach(idx => {
                        const iter = valid_iterations_data[idx];
                        if(iter && iter.a !== null && iter.b !== null && iter.a !== undefined && iter.b !== undefined) {
                             // Mostrar f(a) y f(b) en la gráfica
                            if (typeof iter.fa === 'number') {
                                datasets_bis.push({
                                    label: `f(a) Iter ${iter.iter !== undefined ? iter.iter : idx+1}`,
                                    data: [{x: iter.a, y: iter.fa}],
                                    backgroundColor: 'rgba(255, 159, 64, 0.7)', pointRadius: 4, pointStyle: 'triangle', order:0
                                });
                            }
                             if (typeof iter.fb === 'number') {
                                datasets_bis.push({
                                    label: `f(b) Iter ${iter.iter !== undefined ? iter.iter : idx+1}`,
                                    data: [{x: iter.b, y: iter.fb}],
                                    backgroundColor: 'rgba(153, 102, 255, 0.7)', pointRadius: 4, pointStyle: 'rect', order:0
                                });
                            }
                            // Línea de intervalo
                            datasets_bis.push({
                                label: `Intervalo I${iter.iter !== undefined ? iter.iter : idx+1}: [${iter.a.toFixed(3)}, ${iter.b.toFixed(3)}]`,
                                data: [{x: iter.a, y: -0.5 - idx*0.2}, {x: iter.b, y: -0.5 - idx*0.2}], // Offset en Y más pronunciado
                                borderColor: `hsla(${(idx * 60 + 180) % 360}, 60%, 50%, 0.7)`,
                                borderWidth: 3, type: 'line', fill: false, pointRadius: 0, order: 0 
                            });
                        }
                    });
                }
                
                if (final_root_val !== null && typeof final_root_val === 'number') {
                     datasets_bis.push({
                        label: `Raíz Final (${final_root_val.toFixed(4)})`,
                        data: [{x: final_root_val, y: 0}],
                        backgroundColor: 'rgb(75, 192, 75)', pointRadius: 8, pointStyle: 'star', showLine: false, type: 'scatter', order: 3
                    });
                }
                
                methodChart_BIS = new Chart(ctx_bis, {
                    type: 'scatter', 
                    data: { datasets: datasets_bis },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: { 
                            x: { title: { display: true, text: 'x' } }, 
                            y: { 
                                title: { display: true, text: 'f(x)' }, 
                                grid: { zeroLineColor: 'rgba(0,0,0,1)', zeroLineWidth: 1.5 },
                                afterBuildTicks: chart => chart.ticks.push({value: 0, major: true, label:"0"}) // Asegurar que el eje y=0 se muestre
                            } 
                        },
                        plugins: { 
                            legend: { 
                                position: 'top',
                                labels: { 
                                    filter: (item) => !(item.text.startsWith('f(a) Iter') || item.text.startsWith('f(b) Iter')) || valid_iterations_data.length <=5 
                                }
                            }, 
                            title: { display: true, text: "Método de Bisección: Convergencia Gráfica", font: {size: 16} },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.y !== null) {
                                            label += `(x: ${context.parsed.x.toFixed(6)}, y: ${context.parsed.y.toFixed(6)})`;
                                        }
                                        // Para las estimaciones de raíz, mostrar el error si está disponible
                                        if ((context.dataset.label === 'Estimaciones Raíz (c)') && valid_iterations_data[context.dataIndex] && valid_iterations_data[context.dataIndex].error !== null) {
                                            const errorVal = valid_iterations_data[context.dataIndex].error;
                                            if (typeof errorVal === 'number' && isFinite(errorVal)) {
                                                 label += ` (Error: ${errorVal.toFixed(4)}%)`;
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
                if(chartLoadingMessage_BIS) chartLoadingMessage_BIS.style.display = 'none';
            } catch (error) { 
                if(chartLoadingMessage_BIS) chartLoadingMessage_BIS.textContent = `Error al generar gráfica: ${error.message || String(error)}`; 
                console.error("Error en drawChartJsGraph_BIS para Bisección:", error); 
            }
        }

        // --- Event Listeners y Lógica de Inicialización ---
        if (runCodeButton_BIS) {
            runCodeButton_BIS.addEventListener('click', runCodeNow_BIS);
        }

        if (quizForm_BIS) {
            quizForm_BIS.addEventListener('submit', async function(event) {
                event.preventDefault();
                const currentLocalProgress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
                const submitButton = quizForm_BIS.querySelector('button[type="submit"]');

                if (currentLocalProgress[TASKS_BIS.QUIZ_PASSED] && submitButton.textContent !== 'Intentar de Nuevo') return; // Ya aprobado

                if (submitButton && submitButton.textContent === 'Intentar de Nuevo') {
                    quizForm_BIS.reset();
                    await clearAllVisualFeedback_BIS(true); 
                    if(generalQuizFeedbackDiv_BIS) generalQuizFeedbackDiv_BIS.style.display = 'none';
                    
                    let progressToSave = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
                    progressToSave.user_quiz_answers = {};
                    progressToSave.quiz_current_score = 0;
                    progressToSave.quiz_feedback_active = false; 
                    await savePageProgressToStorage_BIS(PAGE_KEY_BIS, progressToSave);
                    
                    await updateTaskStatusInStorage_BIS(TASKS_BIS.QUIZ_PASSED, false); 
                    // QUIZ_ATTEMPTED permanece true
                    
                    quizForm_BIS.querySelectorAll('input[type="radio"]').forEach(radio => radio.disabled = false);
                    quizForm_BIS.querySelectorAll('.quiz-option-wrapper').forEach(wrapper => { // Re-apply Tailwind default checked styles
                         wrapper.classList.add('has-[:checked]:bg-red-50', 'has-[:checked]:border-custom-red', 'has-[:checked]:ring-1', 'has-[:checked]:ring-custom-red');
                    });
                    submitButton.textContent = 'Enviar Respuestas';
                    return;
                }

                const formData = new FormData(quizForm_BIS);
                let allAnswered = true;
                for (const questionName of Object.keys(quizDataBiseccion)) {
                    if (formData.get(questionName) === null) {
                        allAnswered = false; break;
                    }
                }

                if (!allAnswered) {
                    if (generalQuizFeedbackDiv_BIS) {
                        generalQuizFeedbackDiv_BIS.textContent = "Por favor, responde todas las preguntas antes de enviar el cuestionario.";
                        generalQuizFeedbackDiv_BIS.className = 'mt-4 p-3 rounded-md text-sm bg-yellow-100 text-yellow-700 border border-yellow-200';
                        generalQuizFeedbackDiv_BIS.style.display = 'block';
                    }
                    return;
                }
                
                await updateTaskStatusInStorage_BIS(TASKS_BIS.QUIZ_ATTEMPTED, true);
                let progress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
                progress.user_quiz_answers = {}; // Limpiar respuestas previas antes de guardar las nuevas
                for (const questionName of Object.keys(quizDataBiseccion)) {
                    progress.user_quiz_answers[questionName] = formData.get(questionName);
                }
                progress.quiz_feedback_active = true; 
                await savePageProgressToStorage_BIS(PAGE_KEY_BIS, progress);
                await displayQuizFeedback_BIS();
            });
        }

        if (mainCompletionButton_BIS) {
            async function handleMainCompletionClick_BIS() {
                const progress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
                let allCurrentlyCompleted = ALL_TASK_KEYS_BIS.every(taskKey => progress[taskKey] === true);
                let markAllAs = !allCurrentlyCompleted;

                for (const taskName of ALL_TASK_KEYS_BIS) {
                    await updateTaskStatusInStorage_BIS(taskName, markAllAs);
                }
                
                let updatedProgress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS); // Recargar progreso actualizado
                if (!markAllAs) { // Si se está deshaciendo ("Undo")
                    updatedProgress.user_quiz_answers = {};
                    updatedProgress.quiz_current_score = 0;
                    updatedProgress.quiz_feedback_active = false; // Desactivar feedback visual del quiz
                    if (quizForm_BIS) {
                        quizForm_BIS.reset();
                        quizForm_BIS.querySelectorAll('input[type="radio"]').forEach(radio => radio.disabled = false);
                        const submitButton = quizForm_BIS.querySelector('button[type="submit"]');
                        if(submitButton) submitButton.textContent = 'Enviar Respuestas';
                        quizForm_BIS.querySelectorAll('.quiz-option-wrapper').forEach(wrapper => { // Re-apply Tailwind default checked styles
                            wrapper.classList.add('has-[:checked]:bg-red-50', 'has-[:checked]:border-custom-red', 'has-[:checked]:ring-1', 'has-[:checked]:ring-custom-red');
                        });
                    }
                    await clearAllVisualFeedback_BIS(true); // Limpiar todo el feedback visual
                } else { // Si se está marcando todo como completado
                    // Asegurar que QUIZ_ATTEMPTED y QUIZ_PASSED estén en true
                     updatedProgress[TASKS_BIS.QUIZ_ATTEMPTED] = true;
                     updatedProgress[TASKS_BIS.QUIZ_PASSED] = true;
                    // Si no hay respuestas guardadas, simular un envío con todas correctas para el feedback visual
                    if (Object.keys(updatedProgress.user_quiz_answers).length === 0) {
                        for (const qName in quizDataBiseccion) {
                            updatedProgress.user_quiz_answers[qName] = quizDataBiseccion[qName].correctAnswer;
                        }
                        updatedProgress.quiz_current_score = Object.keys(quizDataBiseccion).length;
                    }
                    updatedProgress.quiz_feedback_active = true;
                }
                await savePageProgressToStorage_BIS(PAGE_KEY_BIS, updatedProgress);
                
                if (quizForm_BIS) await displayQuizFeedback_BIS(); // Actualizar visualización del quiz
                await calculateAndUpdateOverallProgress_BIS(); // Esto también llama a updateMainCompletionButtonState
                
                if (generalQuizFeedbackDiv_BIS && !markAllAs) generalQuizFeedbackDiv_BIS.style.display = 'none';

                // Eliminada la notificación alert para mejorar la experiencia de usuario
                console.log(markAllAs ? 'Todas las tareas marcadas como completadas.' : 'Se ha deshecho el completado de todas las tareas.');
            }
            mainCompletionButton_BIS.addEventListener('click', handleMainCompletionClick_BIS);
        }

        // Observador para la sección de teoría (Conclusión o Teoría)
        const theorySectionObserverTargetNode = document.getElementById('conclusion-metodo') || document.getElementById('teoria');
        if (theorySectionObserverTargetNode) {
            const observerOptions = { root: null, rootMargin: '0px', threshold: 0.1 }; // 10% visible para marcar como leído
            const observerCallback = (entries, observerInstance) => {
                entries.forEach(async entry => {
                    if (entry.isIntersecting) {
                        const currentProgress = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
                        if (!currentProgress[TASKS_BIS.READ_THEORY]) {
                            await updateTaskStatusInStorage_BIS(TASKS_BIS.READ_THEORY, true);
                            await calculateAndUpdateOverallProgress_BIS();
                        }
                        // Considerar unobserve(entry.target) si solo se quiere marcar una vez y no en cada scroll sobre ella
                    }
                });
            };
            const theoryObserver_BIS = new IntersectionObserver(observerCallback, observerOptions);
            theoryObserver_BIS.observe(theorySectionObserverTargetNode);
        }
        
        // Limpiar hash de URL para evitar saltos al recargar y mejorar la detección del IntersectionObserver
        if (window.location.hash) { 
            history.replaceState(null, '', window.location.pathname + window.location.search);
        }
        
        // Auto-ejecutable para inicializar Pyodide y, si es posible, la gráfica
        (async () => { 
            pyodide_BIS = await initializePyodide_BIS();
            // Intentar dibujar la gráfica solo si hay código en el input y las funciones clave ya están en Pyodide
            // Esto usualmente significa que el usuario ya ejecutó el código al menos una vez.
            if (pyodide_BIS && chartCanvas_BIS && codeInput_BIS && codeInput_BIS.value.trim() !== "") {
                // No llamar a drawChartJsGraph_BIS aquí automáticamente al cargar la página,
                // runCodeNow_BIS se encargará de ello después de que el usuario ejecute el código.
                // La idea es que la gráfica se genere DESPUÉS de la ejecución del código del usuario.
                if (chartLoadingMessage_BIS) chartLoadingMessage_BIS.textContent = "Ejecute el código para generar los datos de la gráfica.";

            } else if (chartCanvas_BIS && chartLoadingMessage_BIS) {
                 chartLoadingMessage_BIS.textContent = "Proporcione y ejecute el código para generar la gráfica.";
            }
            // Habilitar el botón de ejecutar código una vez que Pyodide esté listo
            if (pyodide_BIS && runCodeButton_BIS) {
                runCodeButton_BIS.disabled = false;
            } else if (runCodeButton_BIS) {
                runCodeButton_BIS.disabled = true; // Deshabilitar si Pyodide no cargó
            }
        })();

        // Carga inicial del estado del cuestionario y progreso general
        (async () => {
            const initialProgress_BIS = await getPageProgressFromStorage_BIS(PAGE_KEY_BIS);
            if (initialProgress_BIS.quiz_feedback_active || (initialProgress_BIS[TASKS_BIS.QUIZ_ATTEMPTED] && Object.keys(initialProgress_BIS.user_quiz_answers).length > 0) ) {
                if (quizForm_BIS && initialProgress_BIS.user_quiz_answers) {
                    for (const qName in initialProgress_BIS.user_quiz_answers) {
                        const userAnswer = initialProgress_BIS.user_quiz_answers[qName];
                        // Escapar caracteres especiales en el valor para el selector de atributo CSS
                        const escapedUserAnswer = userAnswer.replace(/([\\()\[\]"'])/g, '\\$1'); // Escapar backslashes, paréntesis, corchetes, comillas
                        try {
                            const radioToSelect = quizForm_BIS.querySelector(`input[name="${qName}"][value="${escapedUserAnswer}"]`);
                            if (radioToSelect) radioToSelect.checked = true;
                        } catch (e) {
                            console.warn(`Error al seleccionar radio para ${qName} con valor ${userAnswer}:`, e);
                        }
                    }
                }
                await displayQuizFeedback_BIS(); 
            } else if (quizForm_BIS) { // Estado inicial si no hay feedback activo
                const submitButton = quizForm_BIS.querySelector('button[type="submit"]');
                if (submitButton) {
                    submitButton.textContent = 'Enviar Respuestas';
                    submitButton.disabled = false;
                }
                quizForm_BIS.querySelectorAll('input[type="radio"]').forEach(radio => radio.disabled = false);
                quizForm_BIS.querySelectorAll('.quiz-option-wrapper').forEach(wrapper => {
                    wrapper.classList.add('has-[:checked]:bg-red-50', 'has-[:checked]:border-custom-red', 'has-[:checked]:ring-1', 'has-[:checked]:ring-custom-red');
                });
                // Reprocesar MathJax después de cargar el estado inicial por si hay LaTeX en las opciones restauradas
                if (window.MathJax && window.MathJax.typesetPromise && quizForm_BIS) {
                    window.MathJax.typesetPromise([quizForm_BIS]).catch(function (err) {
                        console.error('Error al procesar MathJax en carga inicial del cuestionario:', err);
                    });
                }
            }
            await calculateAndUpdateOverallProgress_BIS(); // Llamada final para asegurar que todo esté sincronizado al cargar
        })();
    });
    </script>
    <!-- END BIS SCRIPT -->

<script type="module">
    const { createApp, ref, onMounted, onUnmounted, watch, nextTick } = Vue;

    const LeftSidebar = { // Definición del componente LeftSidebar para Vue
        // props: ['currentSection', 'completedSections', 'methodKey', 'methodName'], // Ejemplo de props si fueran necesarias
        template: `{% raw %}
            <aside 
                :class="[
                    'bg-gradient-to-b from-red-500 to-red-700', 'shadow-xl', 'rounded-lg', 'p-4',
                    'flex', 'flex-col',
                    'transition-all', 'duration-300', 'ease-in-out',
                    'order-1', 
                    isCollapsed ? 'w-full lg:w-20' : 'w-full lg:w-64',
                    'self-start', 
                    'lg:sticky', 'lg:top-8', 
                    'lg:max-h-[calc(100vh-4rem)]', 
                    'overflow-y-auto'
                ]"
                aria-label="Sidebar de navegación del método">
                <div class="flex justify-between items-center mb-4 border-b border-red-400 pb-3">
                    <h3 v-show="!isCollapsed" class="text-lg font-semibold text-white select-none">Contenido</h3>
                    <button @click="toggleCollapse" class="p-1.5 ml-2 text-white hover:bg-red-700 rounded focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-75" :aria-label="isCollapsed ? 'Expandir menú' : 'Colapsar menú'">
                        <svg v-if="!isCollapsed" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5" />
                        </svg>
                        <svg v-else xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5" />
                        </svg>
                    </button>
                </div>
                <nav v-show="!isCollapsed">
                    <ul class="space-y-1">
                        <li v-for="item in navItems" :key="item.id">
                            <a :href="item.href"
                               @click.prevent="smoothScroll(item.href)"
                               :class="[
                                   'nav-link block px-4 py-2 rounded-md text-sm font-medium transition-colors duration-150 flex items-center',
                                   isActive(item.id) ? 'bg-white text-custom-blue font-semibold shadow-sm' : 'text-red-100 hover:bg-red-700 hover:text-white'
                               ]">
                                <span v-html="item.iconSVG" class="mr-3 translate-y-px"></span>
                                <span>{{ item.text }}</span>
                            </a>
                        </li>
                    </ul>
                </nav>
                <nav v-show="isCollapsed" class="mt-4">
                     <ul class="space-y-1">
                        <li v-for="item in navItems" :key="item.id + '-collapsed'">
                            <a :href="item.href"
                               @click.prevent="smoothScroll(item.href)"
                               :title="item.text"
                               :aria-label="item.text"
                               :class="[
                                   'nav-link-collapsed block py-2 pl-2.5 pr-1.5 rounded-md transition-colors duration-150 flex justify-center items-center',
                                   isActive(item.id) ? 'bg-white text-custom-blue shadow-sm' : 'text-red-100 hover:bg-red-700 hover:text-white'
                               ]">
                                <span v-html="item.iconSVG" class="w-6 h-6 translate-y-px"></span>
                            </a>
                        </li>
                    </ul>
                </nav>
            </aside>
        {% endraw %}`,
        setup() {
            const isCollapsed = ref(false);
            const activeSectionId = ref(null);
            const navItems = ref([
                { id: 'teoria', text: 'Fundamento Teórico', href: '#teoria', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25" /></svg>' },
                { id: 'algoritmo', text: 'Pasos del Algoritmo', href: '#algoritmo', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 12h16.5m-16.5 3.75h16.5M3.75 19.5h16.5M5.625 4.5h12.75a1.875 1.875 0 010 3.75H5.625a1.875 1.875 0 010-3.75z" /></svg>' },
                { id: 'ejemplo', text: 'Ejemplo Detallado', href: '#ejemplo', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" /></svg>' },
                { id: 'codigo', text: 'Implementación (Python)', href: '#codigo', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M6.75 7.5l3 2.25-3 2.25m4.5 0h3m-9 8.25h13.5A2.25 2.25 0 0021 18V6a2.25 2.25 0 00-2.25-2.25H5.25A2.25 2.25 0 003 6v12a2.25 2.25 0 002.25 2.25z" /></svg>' },
                { id: 'graficas', text: 'Gráficas Interactivas', href: '#graficas', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" /></svg>' },
                { id: 'videos', text: 'Videos Explicativos', href: '#videos', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15.91 11.672a.75.75 0 010 1.656l-5.603 3.113A.75.75 0 019 15.95V9.05a.75.75 0 011.307-.588l5.603 3.112z" /></svg>' },
                { id: 'conclusion-metodo', text: 'Conclusión y Aplicaciones', href: '#conclusion-metodo', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z" /></svg>' },
                { id: 'referencias', text: 'Referencias', href: '#referencias', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 3.75V16.5L12 14.25L7.5 16.5V3.75m9 0H18A2.25 2.25 0 0120.25 6v12A2.25 2.25 0 0118 20.25H6A2.25 2.25 0 013.75 18V6A2.25 2.25 0 016 3.75h1.5m9 0h-9" /></svg>' },
                { id: 'cuestionario', text: 'Cuestionario', href: '#cuestionario', iconSVG: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z" /></svg>' }
            ]);

            let sections = [];

            const toggleCollapse = () => {
                isCollapsed.value = !isCollapsed.value;
                // Consider dispatching an event if other parts of the app need to know about sidebar state
                // window.dispatchEvent(new CustomEvent('sidebarToggled')); 
            };

            const isActive = (id) => {
                return activeSectionId.value === id;
            };
            
            const smoothScroll = (targetHref) => {
                const targetId = targetHref.substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    // The class 'scroll-mt-24' on sections should handle the header offset
                    targetElement.scrollIntoView({
                        behavior: "smooth",
                        block: "start" 
                    });
                    // Optionally update URL hash, though scrollspy will also do this by setting activeSectionId
                    history.pushState(null, null, targetHref); 
                }
            };

            const handleScroll = () => {
                if (!sections || sections.length === 0) return;

                // scroll-mt-24 translates to 6rem or 96px. This is the offset.
                const scrollMarginTopValue = parseInt(getComputedStyle(sections[0]).scrollMarginTop) || 96; 
                let newActiveSectionId = null;

                for (let i = 0; i < sections.length; i++) {
                    const section = sections[i];
                    const sectionTopBoundary = section.offsetTop - scrollMarginTopValue;
                    const sectionBottomBoundary = sectionTopBoundary + section.offsetHeight;

                    // Check if the current scroll position is within this section's boundaries
                    if (window.scrollY >= sectionTopBoundary && window.scrollY < sectionBottomBoundary) {
                        newActiveSectionId = section.id;
                        break;
                    }
                }
                
                // If no section is strictly "active" (e.g., scrolled past the last one, or before the first one with offset)
                // this logic tries to find the "closest" one above the current scroll position.
                if (newActiveSectionId === null && sections.length > 0) {
                    for (let i = sections.length - 1; i >= 0; i--) {
                        const section = sections[i];
                        if ((section.offsetTop - scrollMarginTopValue) <= window.scrollY + 5) { // +5 for a small tolerance
                            newActiveSectionId = section.id;
                            break;
                        }
                    }
                }
                // Default to first section if nothing else is active (e.g. at the very top)
                 if (newActiveSectionId === null && sections.length > 0 && window.scrollY < (sections[0].offsetTop - scrollMarginTopValue)) {
                    newActiveSectionId = sections[0].id;
                 }


                if (activeSectionId.value !== newActiveSectionId) {
                    activeSectionId.value = newActiveSectionId;
                }
            };

            onMounted(() => {
                // Ensure sections are queried after DOM is ready
                nextTick(() => {
                    sections = Array.from(document.querySelectorAll('main article section[id]'));
                    handleScroll(); // Initial check
                    window.addEventListener('scroll', handleScroll, { passive: true });
                });
            });

            onUnmounted(() => {
                window.removeEventListener('scroll', handleScroll);
            });

            return {
                isCollapsed,
                toggleCollapse,
                navItems,
                isActive,
                smoothScroll,
                activeSectionId // Expose if needed, though isActive uses it internally
            };
        }
    };

    const app = createApp({
        components: {
            LeftSidebar
        },
        setup() {
            const METHOD_KEY = "biseccion"; // Clave específica para esta página
            const METHOD_NAME_TITLE_CASE = "Bisección"; // Nombre para mostrar

            const currentSection = ref('');
            const completedSections = ref({}); // Para la completitud de secciones en LeftSidebar

            const updateActiveSection = () => {
                const sections = document.querySelectorAll('main article section[id]');
                let activeSectionId = '';
                let minDistance = Infinity;

                sections.forEach(section => {
                    const rect = section.getBoundingClientRect();
                    // Considerar una sección como activa si su parte superior está cerca de la parte superior de la ventana
                    // o si una parte significativa de ella es visible.
                    const distanceToTop = Math.abs(rect.top);
                     if (rect.top <= 100 && rect.bottom >= 100) { // 100px desde el top como umbral
                        if (distanceToTop < minDistance) {
                           minDistance = distanceToTop;
                           activeSectionId = section.id;
                        }
                    }
                });
                if (activeSectionId) {
                  currentSection.value = activeSectionId;
                } else if (sections.length > 0 && window.scrollY === 0) {
                    currentSection.value = sections[0].id; // Default to first if at top
                }
            };
            
            const updateCompletedSectionsForSidebar = () => {
                // Esta función leerá el progreso desde el localStorage gestionado por el script BIS_SCRIPT
                // y actualizará \`completedSections\` para el LeftSidebar.
                const progressData = JSON.parse(localStorage.getItem(METHOD_KEY) || '{}');
                const newCompleted = {};
                if (progressData.read_theory) newCompleted.teoria = true; // Asumiendo que 'teoria' cubre algoritmo y ejemplo
                if (progressData.run_code) newCompleted.codigo = true;
                if (progressData.quiz_passed) newCompleted.cuestionario = true;
                // Añadir más mapeos si es necesario para otras secciones (videos, gráficas, conclusión, referencias)
                // Por ahora, mantenemos simple, o podríamos inferirlos si queremos que todo se marque
                // con la finalización de las tareas principales.
                completedSections.value = newCompleted;
            };


            onMounted(() => {
                updateActiveSection(); // Initial check
                window.addEventListener('scroll', updateActiveSection);
                
                // Para actualizar el LeftSidebar basado en el progreso del RightSidebar (BIS_SCRIPT)
                updateCompletedSectionsForSidebar();
                window.addEventListener('storage', (event) => { // Escuchar cambios en localStorage
                    if (event.key === METHOD_KEY) {
                        updateCompletedSectionsForSidebar();
                    }
                });
                 // También llamar cuando el BIS_SCRIPT actualiza su localStorage internamente
                const originalSavePageProgressToStorage_BIS = window.savePageProgressToStorage_BIS;
                if (typeof originalSavePageProgressToStorage_BIS === 'function') {
                    window.savePageProgressToStorage_BIS = function(...args) {
                        originalSavePageProgressToStorage_BIS.apply(this, args);
                        updateCompletedSectionsForSidebar(); // Actualizar sidebar de Vue
                    };
                }


                // Asegurar que MathJax procese el contenido después de que Vue lo renderice.
                if (window.MathJax && window.MathJax.typesetPromise) {
                    nextTick(() => {
                        window.MathJax.typesetPromise();
                    });
                }
            });

            onUnmounted(() => {
                window.removeEventListener('scroll', updateActiveSection);
                 // Aquí podrías querer restaurar la función original de savePageProgressToStorage_BIS si es necesario,
                 // aunque para una SPA de una sola página no es crítico.
            });
            
            watch(currentSection, (newHash) => {
                 if (newHash && history.state?.current !== `#${newHash}`) {
                    // No usar pushState aquí para evitar bucles, scrollspy solo actualiza estado.
                 }
            });

            return {
                currentSectionProps: currentSection,
                completedSectionsProps: completedSections,
                methodKeyProps: METHOD_KEY,
                methodNameProps: METHOD_NAME_TITLE_CASE
            };
        }
    });

    app.config.compilerOptions.isCustomElement = tag => tag.startsWith('mjx-');
    app.mount('#app');

</script>

    <!-- Script para controlar el preloader -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Forzar un tiempo mínimo de carga para el preloader
            const MIN_LOADING_TIME = 1800; // Aumentado para dar más tiempo a los componentes Vue
            const loadStartTime = Date.now();
            
            // Bandera para verificar si Vue está listo
            window.vueReady = false;
            
            // Ocultar el preloader y mostrar el contenido cuando todo esté cargado
            const revealContent = function() {
                // Verificar si Vue está listo
                if (!window.vueReady) {
                    console.log('Esperando a que Vue esté listo...');
                    setTimeout(revealContent, 100);
                    return;
                }
                
                const timeElapsed = Date.now() - loadStartTime;
                const additionalWait = Math.max(0, MIN_LOADING_TIME - timeElapsed);
                
                // Esperar al menos el tiempo mínimo de carga
                setTimeout(function() {
                    // Primero hacer visible pero con opacidad 0
                    document.body.classList.add('content-ready');
                    
                    // Luego de un breve momento, hacer la transición de opacidad
                    setTimeout(function() {
                        document.body.classList.add('loaded');
                        const preloader = document.getElementById('sidebar-preloader');
                        if (preloader) {
                            preloader.classList.add('hidden');
                        }
                    }, 100);
                }, additionalWait);
            };
            
            // Ejecutar después de la carga de la ventana
            window.addEventListener('load', function() {
                // Asegurar que MathJax termine de renderizar (si existe)
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise().then(function() {
                        // Añadir demora adicional para contenido dinámico
                        setTimeout(revealContent, 800); // Aumentado para dar más tiempo
                    });
                } else {
                    // Si no hay MathJax, añadir demora de todos modos
                    setTimeout(revealContent, 1000); // Aumentado para dar más tiempo
                }
            });
            
            // Como respaldo, si la carga tarda demasiado, mostrar el contenido
            setTimeout(function() {
                if (!document.body.classList.contains('loaded')) {
                    console.log('Activando temporizador de respaldo');
                    window.vueReady = true; // Forzar que Vue se considere listo
                    document.body.classList.add('content-ready');
                    setTimeout(function() {
                        document.body.classList.add('loaded');
                        const preloader = document.getElementById('sidebar-preloader');
                        if (preloader) {
                            preloader.classList.add('hidden');
                        }
                        console.log('Fallback timer triggered for page load');
                    }, 100);
                }
            }, 3000); // Aumentado a 3 segundos para dar más tiempo
        });
        
    });
</script>

<script>
    // Cuando la aplicación Vue esté montada, marcar como listo
    document.addEventListener('DOMContentLoaded', function() {
        // Dar tiempo para que Vue se monte completamente
        setTimeout(function() {
            window.vueReady = true;
            console.log('Vue marcado como listo');
        }, 500);
    });
</script>
</body>
</html>